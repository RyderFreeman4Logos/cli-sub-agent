[plan]
name = "sa"
description = "Three-tier recursive delegation: Tier 0 dispatches, Tier 1 plans/implements, Tier 2 explores/fixes"

[[plan.variables]]
name = "IMPL_FILE"

[[plan.variables]]
name = "LAST_LINE"

[[plan.variables]]
name = "PROMPT_FILE"

[[plan.variables]]
name = "RESUME_FILE"

[[plan.variables]]
name = "REVIEW_IS_CLEAN"

[[plan.variables]]
name = "SESSION_ID"

[[plan.variables]]
name = "USER_APPROVES"

[[plan.variables]]
name = "USER_MODIFIES"

[[plan.steps]]
id = 1
title = "Validate Task Scope"
prompt = """
Determine if sa is appropriate:
- Multi-step feature (planning + implementation) → use sa
- Cross-cutting concerns (>3 files) → use sa
- Wants heterogeneous review → use sa
- Single well-defined task → use csa run directly instead"""
on_fail = "abort"

[[plan.steps]]
id = 2
title = "Prepare Planning Prompt"
prompt = """
Build planning prompt with user's requirements.
NEVER pre-read files — Tier 1 and Tier 2 read files natively.
Use mktemp for temp files (no race conditions).

```bash
PROMPT_FILE=$(mktemp /tmp/sa-planning-XXXXXX.txt)
```"""
on_fail = "abort"

[[plan.steps]]
id = 3
title = "Dispatch Planning to Tier 1"
tool = "bash"
prompt = """
Tier 1 (claude-code) will:
1. Spawn up to 3 parallel Tier 2 workers for codebase exploration
2. Synthesize findings into TODO draft
3. Run adversarial debate via csa debate
4. Write result.toml with todo_path

```bash
csa run --tool claude-code < "${PROMPT_FILE}"
```"""
on_fail = "abort"

[[plan.steps]]
id = 4
title = "Parse Planning Result"
tool = "bash"
prompt = """
Extract session_id, status, and todo_path from result.toml.
Validate artifact paths don't escape session directory.

```bash
RESULT_PATH="${LAST_LINE}"
SESSION_ID=$(grep 'session_id = ' "$RESULT_PATH" | cut -d'"' -f2)
STATUS=$(grep 'status = ' "$RESULT_PATH" | head -1 | cut -d'"' -f2)
```"""
on_fail = "abort"

[[plan.steps]]
id = 5
title = "Present TODO to User"
prompt = "Present the TODO path to user. Let them read and approve/modify."
on_fail = "abort"

[[plan.steps]]
id = 6
title = "Dispatch Implementation to Tier 1"
tool = "bash"
prompt = """
Resume the Tier 1 session for implementation.
Tier 1 will: implement → delegate errors to Tier 2 → review → commit.

```bash
IMPL_FILE=$(mktemp /tmp/sa-impl-XXXXXX.txt)
csa run --tool claude-code --session "${SESSION_ID}" < "${IMPL_FILE}"
```"""
on_fail = "abort"
condition = "${USER_APPROVES}"

[[plan.steps]]
id = 7
title = "Step 6a: Resume with Feedback"
tool = "bash"
prompt = """
Resume Tier 1 with user's revision feedback.

```bash
RESUME_FILE=$(mktemp /tmp/sa-resume-XXXXXX.txt)
csa run --tool claude-code --session "${SESSION_ID}" < "${RESUME_FILE}"
```"""
on_fail = "abort"
condition = "!(${USER_APPROVES})"

[[plan.steps]]
id = 8
title = "Step 6b: Abandon Plan"
prompt = "User rejected. Stop and ask for new direction."
on_fail = "abort"
condition = "!(${USER_APPROVES})"

[[plan.steps]]
id = 9
title = "Parse Implementation Result"
tool = "bash"
prompt = """
Extract commit_hash, review_result, tasks_completed from result.toml.

```bash
RESULT_PATH="${LAST_LINE}"
COMMIT=$(grep 'commit_hash = ' "$RESULT_PATH" | cut -d'"' -f2)
REVIEW=$(grep 'review_result = ' "$RESULT_PATH" | cut -d'"' -f2)
```"""
on_fail = "abort"

[[plan.steps]]
id = 10
title = "Report to User"
prompt = """
Present implementation results: commit hash, review status,
number of tasks completed. If HAS_ISSUES, iterate."""
on_fail = "abort"

[[plan.steps]]
id = 11
title = "Auto PR"
prompt = ""
on_fail = "abort"
condition = "${REVIEW_IS_CLEAN}"

[[plan.steps]]
id = 12
title = "Include commit"
tool = "weave"
prompt = "commit"
on_fail = "abort"
condition = "${REVIEW_IS_CLEAN}"
