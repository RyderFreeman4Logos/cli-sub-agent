[workflow]
name = "sa"
description = "Three-tier recursive delegation: Tier 0 dispatches, Tier 1 plans/implements, Tier 2 explores/fixes"

[[workflow.variables]]
name = "IMPL_FILE"

[[workflow.variables]]
name = "LAST_LINE"

[[workflow.variables]]
name = "PROMPT_FILE"

[[workflow.variables]]
name = "RESUME_FILE"

[[workflow.variables]]
name = "REVIEW_IS_CLEAN"

[[workflow.variables]]
name = "SESSION_ID"

[[workflow.variables]]
name = "USER_APPROVES"

[[workflow.variables]]
name = "USER_MODIFIES"

[[workflow.steps]]
id = 1
title = "Validate Task Scope"
prompt = """
Determine if sa is appropriate:
- Multi-step feature (planning + implementation) → use sa
- Cross-cutting concerns (>3 files) → use sa
- Wants heterogeneous review → use sa
- Single well-defined task → use csa run directly instead"""
on_fail = "abort"

[[workflow.steps]]
id = 2
title = "Prepare Planning Prompt"
prompt = """
Build planning prompt with user's requirements.
NEVER pre-read files — Tier 1 and Tier 2 read files natively.
Use mktemp for temp files (no race conditions).

```bash
PROMPT_FILE=$(mktemp /tmp/sa-planning-XXXXXX.txt)
```"""
on_fail = "abort"

[[workflow.steps]]
id = 3
title = "Dispatch Planning to Tier 1"
tool = "bash"
prompt = """
Tier 1 (claude-code) will:
1. Spawn up to 3 parallel Tier 2 workers for codebase exploration
2. Synthesize findings into TODO draft
3. Run adversarial debate via csa debate
4. Write `result.toml` (with `todo_path`) in CSA session state dir

```bash
csa run --tool claude-code < "${PROMPT_FILE}"
```"""
on_fail = "abort"

[[workflow.steps]]
id = 4
title = "Parse Planning Result"
tool = "bash"
prompt = """
Extract session_id, status, and todo_path from CSA session `result.toml`.
Validate result and TODO paths stay inside CSA state directories.

```bash
RESULT_PATH="${LAST_LINE}"
RESULT_REAL=$(realpath "${RESULT_PATH}" 2>/dev/null) || { echo "result.toml path invalid: ${RESULT_PATH}" >&2; exit 1; }
[ -f "${RESULT_REAL}" ] || { echo "result.toml not found: ${RESULT_REAL}" >&2; exit 1; }
CSA_STATE_ROOT="${RESULT_REAL%/sessions/*/result.toml}"
[[ "${CSA_STATE_ROOT}" != "${RESULT_REAL}" ]] || { echo "Cannot derive state root: ${RESULT_REAL}" >&2; exit 1; }
SESSION_ID=$(grep -- 'session_id = ' "$RESULT_REAL" | cut -d'"' -f2)
STATUS=$(grep -- 'status = ' "$RESULT_REAL" | head -1 | cut -d'"' -f2)
TODO_PATH=$(grep -- 'todo_path = ' "$RESULT_REAL" | cut -d'"' -f2)
TODO_REAL=$(realpath "${TODO_PATH}" 2>/dev/null) || { echo "TODO path invalid: ${TODO_PATH}" >&2; exit 1; }
[ -f "${TODO_REAL}" ] || { echo "TODO not found: ${TODO_REAL}" >&2; exit 1; }
[[ "${TODO_REAL}" == "${CSA_STATE_ROOT}"/todos/*/TODO.md ]] || { echo "TODO escapes state root: ${TODO_REAL}" >&2; exit 1; }
```"""
on_fail = "abort"

[[workflow.steps]]
id = 5
title = "Present TODO to User"
prompt = "Present the TODO path to user. Let them read and approve/modify."
on_fail = "abort"

[[workflow.steps]]
id = 6
title = "Dispatch Implementation to Tier 1"
tool = "bash"
prompt = """
Resume the Tier 1 session for implementation.
Tier 1 will: implement → delegate errors to Tier 2 → review → commit.

```bash
IMPL_FILE=$(mktemp /tmp/sa-impl-XXXXXX.txt)
csa run --tool claude-code --session "${SESSION_ID}" < "${IMPL_FILE}"
```"""
on_fail = "abort"
condition = "${USER_APPROVES}"

[[workflow.steps]]
id = 7
title = "Step 6a: Resume with Feedback"
tool = "bash"
prompt = """
Resume Tier 1 with user's revision feedback.

```bash
RESUME_FILE=$(mktemp /tmp/sa-resume-XXXXXX.txt)
csa run --tool claude-code --session "${SESSION_ID}" < "${RESUME_FILE}"
```"""
on_fail = "abort"
condition = "(!(${USER_APPROVES})) && (${USER_MODIFIES})"

[[workflow.steps]]
id = 8
title = "Step 6b: Abandon Plan"
prompt = "User rejected. Stop and ask for new direction."
on_fail = "abort"
condition = "(!(${USER_APPROVES})) && (!(${USER_MODIFIES}))"

[[workflow.steps]]
id = 9
title = "Parse Implementation Result"
tool = "bash"
prompt = """
Extract commit_hash, review_result, tasks_completed from CSA session `result.toml`.

```bash
RESULT_PATH="${LAST_LINE}"
RESULT_REAL=$(realpath "${RESULT_PATH}" 2>/dev/null) || { echo "result.toml path invalid: ${RESULT_PATH}" >&2; exit 1; }
[ -f "${RESULT_REAL}" ] || { echo "result.toml not found: ${RESULT_REAL}" >&2; exit 1; }
CSA_STATE_ROOT="${RESULT_REAL%/sessions/*/result.toml}"
[[ "${CSA_STATE_ROOT}" != "${RESULT_REAL}" ]] || { echo "Cannot derive state root: ${RESULT_REAL}" >&2; exit 1; }
COMMIT=$(grep -- 'commit_hash = ' "$RESULT_REAL" | cut -d'"' -f2)
REVIEW=$(grep -- 'review_result = ' "$RESULT_REAL" | cut -d'"' -f2)
```"""
on_fail = "abort"

[[workflow.steps]]
id = 10
title = "Report to User"
prompt = """
Present implementation results: commit hash, review status,
number of tasks completed. If HAS_ISSUES, iterate."""
on_fail = "abort"

[[workflow.steps]]
id = 11
title = "Auto PR"
prompt = ""
on_fail = "abort"
condition = "${REVIEW_IS_CLEAN}"

[[workflow.steps]]
id = 12
title = "Include commit"
tool = "weave"
prompt = "commit"
on_fail = "abort"
condition = "${REVIEW_IS_CLEAN}"
