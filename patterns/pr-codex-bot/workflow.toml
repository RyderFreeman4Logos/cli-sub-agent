[workflow]
name = "pr-codex-bot"
description = "Iterative PR review loop with cloud codex bot: local review, push, bot trigger, false-positive arbitration, fix, merge"

[[workflow.variables]]
name = "CLOUD_BOT"

[[workflow.variables]]
name = "BOT_COMMENTS"

[[workflow.variables]]
name = "BOT_HAS_ISSUES"

[[workflow.variables]]
name = "BOT_UNAVAILABLE"

[[workflow.variables]]
name = "CLEAN_BRANCH"

[[workflow.variables]]
name = "COMMENT_IS_FALSE_POSITIVE"

[[workflow.variables]]
name = "COMMENT_IS_STALE"

[[workflow.variables]]
name = "FALLBACK_REVIEW_HAS_ISSUES"

[[workflow.variables]]
name = "FIXES_ACCUMULATED"

[[workflow.variables]]
name = "LOCAL_REVIEW_HAS_ISSUES"

[[workflow.variables]]
name = "MAX_REVIEW_ROUNDS"

[[workflow.variables]]
name = "PR_BODY"

[[workflow.variables]]
name = "PR_NUM"

[[workflow.variables]]
name = "PR_TITLE"

[[workflow.variables]]
name = "REBASE_REVIEW_HAS_ISSUES"

[[workflow.variables]]
name = "REPO"

[[workflow.variables]]
name = "REVIEW_ROUND"

[[workflow.variables]]
name = "ROUND_LIMIT_ACTION"

[[workflow.variables]]
name = "ROUND_LIMIT_REACHED"

[[workflow.variables]]
name = "WORKFLOW_BRANCH"

[[workflow.steps]]
id = 1
title = "Commit Changes"
tool = "bash"
prompt = """
Ensure all changes committed. Set WORKFLOW_BRANCH once (persists through
clean branch switches in Step 11).

```bash
WORKFLOW_BRANCH="$(git branch --show-current)"
```"""
on_fail = "abort"

[[workflow.steps]]
id = 2
title = "Local Pre-PR Review (SYNCHRONOUS — MUST NOT background)"
tool = "bash"
prompt = """
Run cumulative local review covering all commits since main, with SHA-verified
fast-path. This is the FOUNDATION — without it, bot unavailability cannot
safely merge.

```bash
CURRENT_HEAD="$(git rev-parse HEAD)"
REVIEW_HEAD="$(csa session list --recent-review 2>/dev/null | parse_head_sha || true)"
if [ -n "${REVIEW_HEAD}" ] && [ "${CURRENT_HEAD}" = "${REVIEW_HEAD}" ]; then
  echo "Fast-path: latest local review already covers HEAD ${CURRENT_HEAD}; skip Step 2 review."
else
  echo "No matching review HEAD found (or HEAD drift detected). Running full local review."
  csa review --branch main
fi
```"""
on_fail = "abort"

[[workflow.steps]]
id = 3
title = "Fix Local Review Issues"
tool = "csa"
prompt = "Fix issues found by local review. Loop until clean (max 3 rounds)."
tier = "tier-2-standard"
condition = "${LOCAL_REVIEW_HAS_ISSUES}"

[workflow.steps.on_fail]
retry = 3

[[workflow.steps]]
id = 4
title = "Push and Create PR"
tool = "bash"
condition = "!(${LOCAL_REVIEW_HAS_ISSUES})"
prompt = """
```bash
git push -u origin "${WORKFLOW_BRANCH}"
gh pr create --base main --title "${PR_TITLE}" --body "${PR_BODY}"
PR_NUM=$(gh pr view --json number -q '.number')
```"""
on_fail = "abort"

[[workflow.steps]]
id = 6
title = "Check Cloud Bot Configuration"
tool = "bash"
prompt = """
Check whether cloud bot review is enabled for this project.
If disabled, set BOT_UNAVAILABLE and apply the same SHA-verified fast-path
before deciding whether supplementary local review is needed.

```bash
CLOUD_BOT=$(csa config get pr_review.cloud_bot --default true)
if [ "${CLOUD_BOT}" = "false" ]; then
  BOT_UNAVAILABLE=true
  CURRENT_HEAD="$(git rev-parse HEAD)"
  REVIEW_HEAD="$(csa session list --recent-review 2>/dev/null | parse_head_sha || true)"
  if [ -n "${REVIEW_HEAD}" ] && [ "${CURRENT_HEAD}" = "${REVIEW_HEAD}" ]; then
    echo "Cloud bot disabled, fast-path active: local review already covers HEAD ${CURRENT_HEAD}."
  else
    echo "Cloud bot disabled and fast-path invalid. Running full local review."
    csa review --branch main
  fi
fi
```"""
on_fail = "skip"

[[workflow.steps]]
id = 5
title = "Trigger Cloud Bot Review and Poll for Response"
tool = "bash"
prompt = """
Trigger @codex review (idempotent — skip if already commented on this HEAD),
then poll for bot response with bounded timeout (max 10 min, 30s interval).
If bot times out, set BOT_UNAVAILABLE and fall through — local review
(Step 2) already covers main...HEAD. On timeout, run fallback local review:
csa review --range main...HEAD.

```bash
# --- Trigger @codex review (idempotent) ---
CURRENT_SHA="$(git rev-parse HEAD)"
EXISTING=$(gh api "repos/${REPO}/issues/${PR_NUM}/comments" \\
  --jq "[.[] | select(.body | test(\\"@codex review\\")) | select(.body | test(\\"${CURRENT_SHA}\\") or (.updated_at > \\"$(git log -1 --format=%cI HEAD~1 2>/dev/null || echo 1970-01-01)\\"))] | length" 2>/dev/null || echo "0")
if [ "${EXISTING}" = "0" ]; then
  gh pr comment "${PR_NUM}" --repo "${REPO}" --body "@codex review"
fi

# --- Poll for bot response (max 10 min) ---
BOT_UNAVAILABLE=true
POLL_INTERVAL=30
MAX_WAIT=600
WAITED=0
while [ "${WAITED}" -lt "${MAX_WAIT}" ]; do
  sleep "${POLL_INTERVAL}"
  WAITED=$((WAITED + POLL_INTERVAL))
  BOT_REPLY=$(gh api "repos/${REPO}/issues/${PR_NUM}/comments" \\
    --jq "[.[] | select(.user.type == \\"Bot\\" or .user.login == \\"codex[bot]\\" or .user.login == \\"codex-bot\\") | select(.created_at > \\"$(git log -1 --format=%cI HEAD)\\")] | length" 2>/dev/null || echo "0")
  if [ "${BOT_REPLY}" -gt 0 ] 2>/dev/null; then
    BOT_UNAVAILABLE=false
    break
  fi
  echo "Polling... ${WAITED}s / ${MAX_WAIT}s"
done

if [ "${BOT_UNAVAILABLE}" = "true" ]; then
  echo "Bot timed out after ${MAX_WAIT}s. Falling back to local review."
  csa review --range main...HEAD 2>/dev/null || true
fi
```"""
on_fail = "skip"

[[workflow.steps]]
id = 7
title = "Step 6a: Merge Without Bot"
tool = "bash"
prompt = """
Bot unavailable. Local review already guarantees coverage.
Push any local commits before merge so remote HEAD includes all fixes.
MANDATORY: Leave an audit trail comment on the PR explaining the merge rationale
(bot timeout + local review CLEAN) before merging.

```bash
git push origin "${WORKFLOW_BRANCH}"

# Audit trail: explain why merging without bot review.
gh pr comment "${PR_NUM}" --repo "${REPO}" --body \
  "**Merge rationale**: Cloud bot (@codex) timed out. Local \`csa review --branch main\` passed CLEAN (or issues were fixed in fallback cycle). Proceeding to merge with local review as the review layer."

gh pr merge "${PR_NUM}" --repo "${REPO}" --squash --delete-branch
git checkout main && git pull origin main
```"""
on_fail = "abort"
condition = "(${BOT_UNAVAILABLE}) && (!(${ROUND_LIMIT_REACHED}))"

[[workflow.steps]]
id = 8
title = "Evaluate Each Bot Comment"
tool = "claude-code"
prompt = """
Classify each bot review comment on PR #${PR_NUM} as:
- Category A (already fixed): the issue was addressed in subsequent commits
- Category B (suspected false positive): the bot misunderstood the code or context
- Category C (real issue): a genuine problem that needs fixing

For each comment, read the referenced code at the current HEAD and compare with
the bot's suggestion. Output a classification table with reasoning."""
tier = "tier-3-complex"
on_fail = "abort"
condition = "(!(${BOT_UNAVAILABLE})) && (${BOT_HAS_ISSUES})"

[[workflow.steps]]
id = 9
title = "Staleness Filter"
tool = "bash"
prompt = """
For each bot comment, check if the referenced code has been modified since the
comment was posted. Compare comment file paths and line ranges against the latest
HEAD diff (git diff main...HEAD). Comments that reference lines/hunks modified
after the comment timestamp are marked as COMMENT_IS_STALE. Stale comments are
skipped before arbitration — they do not enter the debate step.

```bash
# For each comment: extract file path and line range from bot comment body.
# Compare against: git log --since="${COMMENT_TIMESTAMP}" --oneline -- "${FILE}"
# If file/lines changed after comment: mark COMMENT_IS_STALE=true
# Stale comments are reclassified as Category A (already addressed).
```"""
on_fail = "skip"
condition = "(!(${BOT_UNAVAILABLE})) && (${BOT_HAS_ISSUES})"

[workflow.steps.loop_var]
variable = "comment"
collection = "${BOT_COMMENTS}"

[[workflow.steps]]
id = 10
title = "Arbitrate via Debate"
tool = "csa"
prompt = """
Evaluate this bot review comment independently to determine if it is a
false positive or a real issue.

Read the referenced code at the current HEAD. Consider:
1. Does the code actually have the problem the bot describes?
2. Is the bot's suggestion appropriate for this context?
3. Are there project-specific patterns that justify the current code?

Output: CONFIRMED (real issue) or DISMISSED (false positive) with reasoning.
Post the full audit trail as a PR comment."""
tier = "tier-2-standard"
on_fail = "abort"
condition = "(!(${BOT_UNAVAILABLE})) && ((${BOT_HAS_ISSUES}) && ((${COMMENT_IS_FALSE_POSITIVE}) && (!(${COMMENT_IS_STALE}))))"

[workflow.steps.loop_var]
variable = "comment"
collection = "${BOT_COMMENTS}"

[[workflow.steps]]
id = 11
title = "Fix Real Issue"
tool = "csa"
prompt = "Fix the real issue. Commit the fix."
tier = "tier-2-standard"
condition = "(!(${BOT_UNAVAILABLE})) && ((${BOT_HAS_ISSUES}) && (!(${COMMENT_IS_FALSE_POSITIVE})) && (!(${COMMENT_IS_STALE})))"

[workflow.steps.on_fail]
retry = 2

[workflow.steps.loop_var]
variable = "comment"
collection = "${BOT_COMMENTS}"

[[workflow.steps]]
id = 12
title = "Push Fixes and Re-trigger"
tool = "bash"
prompt = """
Track iteration count via REVIEW_ROUND. Check the round cap BEFORE pushing
fixes and triggering another bot review.

When REVIEW_ROUND reaches MAX_REVIEW_ROUNDS (default: 10), STOP and present
options to the user — no new review is triggered until the user decides:
- Option A: Merge now (review is good enough)
- Option B: Continue for MAX_REVIEW_ROUNDS more rounds
- Option C: Abort and investigate manually

The workflow MUST NOT auto-merge or auto-abort at the round limit.

Orchestrator protocol: When the round cap is hit, the bash block exits with
code 0 after printing ROUND_LIMIT_HALT. The orchestrator MUST then use
AskUserQuestion to present options A/B/C and collect the user's choice.

Signal disambiguation: ROUND_LIMIT_HALT (exit 0) = ask user.
ROUND_LIMIT_MERGE (exit 0) = proceed to merge. ROUND_LIMIT_ABORT (exit 1) = stop.

```bash
REVIEW_ROUND=$((REVIEW_ROUND + 1))
MAX_REVIEW_ROUNDS="${MAX_REVIEW_ROUNDS:-10}"

# --- Handle orchestrator re-entry with user decision (FIRST) ---
if [ -n "${ROUND_LIMIT_ACTION}" ]; then
  case "${ROUND_LIMIT_ACTION}" in
    merge)
      echo "User chose: Merge now. Pushing local commits before merge."
      ROUND_LIMIT_REACHED=false
      git push origin "${WORKFLOW_BRANCH}"
      echo "ROUND_LIMIT_MERGE: Routing to merge step."
      exit 0
      ;;
    continue)
      echo "User chose: Continue. Extending by ${MAX_REVIEW_ROUNDS} rounds."
      ROUND_LIMIT_REACHED=false
      MAX_REVIEW_ROUNDS=$((REVIEW_ROUND + MAX_REVIEW_ROUNDS))
      unset ROUND_LIMIT_ACTION
      ;;
    abort)
      echo "User chose: Abort workflow."
      echo "ROUND_LIMIT_ABORT: Workflow terminated by user."
      exit 1
      ;;
  esac
fi

# --- Round cap check BEFORE push/trigger ---
if [ "${REVIEW_ROUND}" -ge "${MAX_REVIEW_ROUNDS}" ]; then
  ROUND_LIMIT_REACHED=true
  echo "Reached MAX_REVIEW_ROUNDS (${MAX_REVIEW_ROUNDS})."
  echo "Options:"
  echo "  A) Merge now (review is good enough)"
  echo "  B) Continue for ${MAX_REVIEW_ROUNDS} more rounds"
  echo "  C) Abort and investigate manually"
  echo ""
  echo "ROUND_LIMIT_HALT: Awaiting user decision."
  exit 0
fi

# --- Push fixes and re-trigger bot review ---
git push origin "${WORKFLOW_BRANCH}"
gh pr comment "${PR_NUM}" --repo "${REPO}" --body "@codex review"
```

Loop back to Step 5 (poll)."""
on_fail = "abort"
condition = "(!(${BOT_UNAVAILABLE})) && (${BOT_HAS_ISSUES})"

[[workflow.steps]]
id = 13
title = "Step 10a: Bot Review Clean"
prompt = "No issues found by bot. Proceed to Step 10.5 (rebase) then merge."
on_fail = "abort"
condition = "(!(${BOT_UNAVAILABLE})) && (!(${BOT_HAS_ISSUES})) && (!(${ROUND_LIMIT_REACHED}))"

[[workflow.steps]]
id = 17
title = "Step 10.5: Rebase for Clean History"
tool = "bash"
prompt = """
When the branch has accumulated fix commits from review iterations,
reorganize them into logical groups before merging. Skip if <= 3 commits.

After rebase, trigger one final @codex review and poll for response.
Evaluate the post-rebase review result: badge detection uses P0/P1/P2
(e.g., **P0**, **P1**, **P2**) to identify actionable findings.

If post-rebase review has issues, run an inline fix cycle (max 3 rounds).
If bot times out, fall back to csa review --range main...HEAD with its
own inline fix cycle.

Push before merge in ALL paths so remote HEAD includes all fixes.

BLOCKING: The orchestrator MUST NOT proceed to merge until the post-rebase
gate passes (REBASE_REVIEW_HAS_ISSUES=false and FALLBACK_REVIEW_HAS_ISSUES
unset or false).

```bash
COMMIT_COUNT=$(git rev-list --count main..HEAD)
if [ "${COMMIT_COUNT}" -gt 3 ]; then
  # 1. Create backup branch (idempotent)
  git branch -f "backup-${PR_NUM}-pre-rebase" HEAD

  # 2. Soft reset to merge-base
  MERGE_BASE=$(git merge-base main HEAD)
  git reset --soft $MERGE_BASE

  # 3. Create logical commits by selectively staging files
  git reset HEAD .
  # Group 1: Source code
  git diff --name-only -z HEAD | grep -zE '^(src/|crates/|lib/|bin/)' | xargs -0 --no-run-if-empty git add --
  if ! git diff --cached --quiet; then
    git commit -m "feat(scope): primary implementation changes"
  fi

  # Group 2: Patterns, skills, and workflow definitions
  git diff --name-only -z HEAD | grep -zE '^(patterns/|\.claude/)' | xargs -0 --no-run-if-empty git add --
  if ! git diff --cached --quiet; then
    git commit -m "fix(scope): pattern and skill updates"
  fi

  # Group 3: Everything else
  git add -A
  if ! git diff --cached --quiet; then
    git commit -m "chore(scope): config and documentation updates"
  fi

  # 4. Verify replacement commits exist
  NEW_COMMIT_COUNT=$(git rev-list --count ${MERGE_BASE}..HEAD)
  if [ "${NEW_COMMIT_COUNT}" -eq 0 ]; then
    echo "ERROR: No replacement commits after soft reset. Restoring backup."
    git reset --hard "backup-${PR_NUM}-pre-rebase"
    exit 1
  fi

  # 5. Force push
  git push --force-with-lease

  # 6. Trigger final @codex review
  gh pr comment "${PR_NUM}" --repo "${REPO}" --body "@codex review"

  # 7. Poll for bot response
  REBASE_BOT_OK=false
  POLL_INTERVAL=30
  MAX_WAIT=600
  WAITED=0
  while [ "${WAITED}" -lt "${MAX_WAIT}" ]; do
    sleep "${POLL_INTERVAL}"
    WAITED=$((WAITED + POLL_INTERVAL))
    BOT_REPLY=$(gh api "repos/${REPO}/issues/${PR_NUM}/comments" \\
      --jq "[.[] | select(.user.type == \\"Bot\\" or .user.login == \\"codex[bot]\\" or .user.login == \\"codex-bot\\") | select(.created_at > \\"$(git log -1 --format=%cI HEAD)\\")] | length" 2>/dev/null || echo "0")
    if [ "${BOT_REPLY}" -gt 0 ] 2>/dev/null; then
      REBASE_BOT_OK=true
      break
    fi
    echo "Post-rebase poll... ${WAITED}s / ${MAX_WAIT}s"
  done

  # 8. BLOCKING: Evaluate final review result
  if [ "${REBASE_BOT_OK}" = "true" ]; then
    REBASE_BOT_ISSUES=$(gh api "repos/${REPO}/issues/${PR_NUM}/comments" \\
      --jq "[.[] | select(.user.type == \\"Bot\\" or .user.login == \\"codex[bot]\\" or .user.login == \\"codex-bot\\") | select(.created_at > \\"$(git log -1 --format=%cI HEAD)\\") | select(.body | test(\\"\\\\*\\\\*P[012]\\\\*\\\\*\\"))] | length" 2>/dev/null || echo "0")

    if [ "${REBASE_BOT_ISSUES}" -gt 0 ] 2>/dev/null; then
      REBASE_REVIEW_HAS_ISSUES=true
      # Inline post-rebase fix cycle (max 3 rounds)
      REBASE_FIX_ROUND=0
      REBASE_FIX_MAX=3
      while [ "${REBASE_REVIEW_HAS_ISSUES}" = "true" ] && [ "${REBASE_FIX_ROUND}" -lt "${REBASE_FIX_MAX}" ]; do
        REBASE_FIX_ROUND=$((REBASE_FIX_ROUND + 1))
        csa run "Fix the issues found by the post-rebase bot review on PR #${PR_NUM}. Read the bot comments and apply fixes. Commit the fixes."
        git push origin "${WORKFLOW_BRANCH}"
        gh pr comment "${PR_NUM}" --repo "${REPO}" --body "@codex review"

        REFIX_BOT_OK=false
        REFIX_WAITED=0
        while [ "${REFIX_WAITED}" -lt "${MAX_WAIT}" ]; do
          sleep "${POLL_INTERVAL}"
          REFIX_WAITED=$((REFIX_WAITED + POLL_INTERVAL))
          REFIX_REPLY=$(gh api "repos/${REPO}/issues/${PR_NUM}/comments" \\
            --jq "[.[] | select(.user.type == \\"Bot\\" or .user.login == \\"codex[bot]\\" or .user.login == \\"codex-bot\\") | select(.created_at > \\"$(git log -1 --format=%cI HEAD)\\")] | length" 2>/dev/null || echo "0")
          if [ "${REFIX_REPLY}" -gt 0 ] 2>/dev/null; then
            REFIX_BOT_OK=true
            break
          fi
        done

        if [ "${REFIX_BOT_OK}" = "true" ]; then
          REFIX_ISSUES=$(gh api "repos/${REPO}/issues/${PR_NUM}/comments" \\
            --jq "[.[] | select(.user.type == \\"Bot\\" or .user.login == \\"codex[bot]\\" or .user.login == \\"codex-bot\\") | select(.created_at > \\"$(git log -1 --format=%cI HEAD)\\") | select(.body | test(\\"\\\\*\\\\*P[012]\\\\*\\\\*\\"))] | length" 2>/dev/null || echo "0")
          if [ "${REFIX_ISSUES}" -eq 0 ] 2>/dev/null; then
            REBASE_REVIEW_HAS_ISSUES=false
          fi
        else
          if csa review --range main...HEAD 2>/dev/null; then
            REBASE_REVIEW_HAS_ISSUES=false
          fi
        fi
      done

      if [ "${REBASE_REVIEW_HAS_ISSUES}" = "true" ]; then
        echo "ERROR: Post-rebase review still failing after ${REBASE_FIX_MAX} rounds. Aborting."
        exit 1
      fi
      git push origin "${WORKFLOW_BRANCH}"
    else
      REBASE_REVIEW_HAS_ISSUES=false
    fi
  else
    # Bot timed out — fallback to local review
    if csa review --range main...HEAD 2>/dev/null; then
      # Audit trail: explain why merging without post-rebase bot review.
      gh pr comment "${PR_NUM}" --repo "${REPO}" --body \\
        "**Merge rationale**: Post-rebase cloud bot timed out. Local csa review --range main...HEAD passed CLEAN. Proceeding to merge with local review as the review layer."
    else
      FALLBACK_REVIEW_HAS_ISSUES=true
      # Inline fallback fix cycle (max 3 rounds)
      REBASE_FB_FIX_ROUND=0
      REBASE_FB_FIX_MAX=3
      while [ "${FALLBACK_REVIEW_HAS_ISSUES}" = "true" ] && [ "${REBASE_FB_FIX_ROUND}" -lt "${REBASE_FB_FIX_MAX}" ]; do
        REBASE_FB_FIX_ROUND=$((REBASE_FB_FIX_ROUND + 1))
        csa run "Fix the issues found by csa review --range main...HEAD. Read the review output and apply fixes. Commit the fixes."
        if csa review --range main...HEAD 2>/dev/null; then
          FALLBACK_REVIEW_HAS_ISSUES=false
        fi
      done
      if [ "${FALLBACK_REVIEW_HAS_ISSUES}" = "true" ]; then
        echo "ERROR: Post-rebase fallback review still failing after ${REBASE_FB_FIX_MAX} rounds. Aborting."
        exit 1
      fi
      git push origin "${WORKFLOW_BRANCH}"
      # Audit trail: explain merge after fix cycle.
      gh pr comment "${PR_NUM}" --repo "${REPO}" --body \\
        "**Merge rationale**: Post-rebase cloud bot timed out. Local csa review --range main...HEAD passed CLEAN after ${REBASE_FB_FIX_ROUND} fix round(s). Proceeding to merge with local review as the review layer."
    fi
  fi
fi
```"""
on_fail = "abort"
condition = "(!(${BOT_UNAVAILABLE})) && (!(${BOT_HAS_ISSUES})) && (!(${ROUND_LIMIT_REACHED}))"

[[workflow.steps]]
id = 14
title = "Clean Resubmission (if needed)"
tool = "bash"
prompt = """
If fixes accumulated, create clean branch for final review.

```bash
CLEAN_BRANCH="${WORKFLOW_BRANCH}-clean"
git checkout -b "${CLEAN_BRANCH}"
git push -u origin "${CLEAN_BRANCH}"
gh pr create --base main --head "${CLEAN_BRANCH}" --title "${PR_TITLE}" --body "${PR_BODY}"
```"""
on_fail = "abort"
condition = "(!(${BOT_UNAVAILABLE})) && (${FIXES_ACCUMULATED}) && (!(${ROUND_LIMIT_REACHED}))"

[[workflow.steps]]
id = 15
title = "Final Merge"
tool = "bash"
prompt = """
Squash-merge and update local main. Hard gate blocks merge if any
post-rebase review issues remain unresolved.

```bash
# --- Hard gate: unconditional pre-merge check ---
if [ "${FALLBACK_REVIEW_HAS_ISSUES}" = "true" ]; then
  echo "ERROR: Reached merge with unresolved fallback review issues."
  exit 1
fi
if [ "${REBASE_REVIEW_HAS_ISSUES}" = "true" ]; then
  echo "ERROR: Reached merge with unresolved post-rebase review issues."
  exit 1
fi

git push origin "${WORKFLOW_BRANCH}"
gh pr merge "${WORKFLOW_BRANCH}-clean" --repo "${REPO}" --squash --delete-branch
git checkout main && git pull origin main
```"""
on_fail = "abort"
condition = "(!(${BOT_UNAVAILABLE})) && (${FIXES_ACCUMULATED}) && (!(${ROUND_LIMIT_REACHED}))"

[[workflow.steps]]
id = 16
title = "Step 12b: Final Merge (Direct)"
tool = "bash"
prompt = """
First-pass clean review: merge the existing PR directly. Hard gate blocks
merge if any post-rebase review issues remain unresolved.

```bash
# --- Hard gate: unconditional pre-merge check ---
if [ "${FALLBACK_REVIEW_HAS_ISSUES}" = "true" ]; then
  echo "ERROR: Reached merge with unresolved fallback review issues."
  exit 1
fi
if [ "${REBASE_REVIEW_HAS_ISSUES}" = "true" ]; then
  echo "ERROR: Reached merge with unresolved post-rebase review issues."
  exit 1
fi

git push origin "${WORKFLOW_BRANCH}"
gh pr merge "${PR_NUM}" --repo "${REPO}" --squash --delete-branch
git checkout main && git pull origin main
```"""
on_fail = "abort"
condition = "(!(${BOT_UNAVAILABLE})) && (!(${FIXES_ACCUMULATED})) && (!(${ROUND_LIMIT_REACHED}))"
