[workflow]
name = "pr-codex-bot"
description = "Iterative PR review loop with cloud codex bot: local review, push, bot trigger, false-positive arbitration, fix, merge"

[[workflow.variables]]
name = "CLOUD_BOT"

[[workflow.variables]]
name = "BOT_COMMENTS"

[[workflow.variables]]
name = "BOT_HAS_ISSUES"

[[workflow.variables]]
name = "BOT_UNAVAILABLE"

[[workflow.variables]]
name = "CLEAN_BRANCH"

[[workflow.variables]]
name = "COMMENT_IS_FALSE_POSITIVE"

[[workflow.variables]]
name = "COMMENT_IS_STALE"

[[workflow.variables]]
name = "FIXES_ACCUMULATED"

[[workflow.variables]]
name = "LOCAL_REVIEW_HAS_ISSUES"

[[workflow.variables]]
name = "PR_BODY"

[[workflow.variables]]
name = "PR_NUM"

[[workflow.variables]]
name = "PR_TITLE"

[[workflow.variables]]
name = "REPO"

[[workflow.variables]]
name = "WORKFLOW_BRANCH"

[[workflow.steps]]
id = 1
title = "Commit Changes"
tool = "bash"
prompt = """
Ensure all changes committed. Set WORKFLOW_BRANCH once (persists through
clean branch switches in Step 11).

```bash
WORKFLOW_BRANCH="$(git branch --show-current)"
```"""
on_fail = "abort"

[[workflow.steps]]
id = 2
title = "Local Pre-PR Review (SYNCHRONOUS — MUST NOT background)"
tool = "bash"
prompt = """
Run cumulative local review covering all commits since main.
This is the FOUNDATION — without it, bot unavailability cannot safely merge.

```bash
csa review --branch main
```"""
on_fail = "abort"

[[workflow.steps]]
id = 3
title = "Fix Local Review Issues"
tool = "csa"
prompt = "Fix issues found by local review. Loop until clean (max 3 rounds)."
tier = "tier-2-standard"
condition = "${LOCAL_REVIEW_HAS_ISSUES}"

[workflow.steps.on_fail]
retry = 3

[[workflow.steps]]
id = 4
title = "Push and Create PR"
tool = "bash"
prompt = """
```bash
git push -u origin "${WORKFLOW_BRANCH}"
gh pr create --base main --title "${PR_TITLE}" --body "${PR_BODY}"
PR_NUM=$(gh pr view --json number -q '.number')
```"""
on_fail = "abort"

[[workflow.steps]]
id = 6
title = "Check Cloud Bot Configuration"
tool = "bash"
prompt = """
Check whether cloud bot review is enabled for this project.
If disabled, set BOT_UNAVAILABLE and run supplementary local review.

```bash
CLOUD_BOT=$(csa config get pr_review.cloud_bot --default true)
if [ "${CLOUD_BOT}" = "false" ]; then
  BOT_UNAVAILABLE=true
  echo "Cloud bot disabled via project config. Running local review instead."
  csa review --range main...HEAD 2>/dev/null || true
fi
```"""
on_fail = "skip"

[[workflow.steps]]
id = 5
title = "Trigger Cloud Bot Review and Poll for Response"
tool = "bash"
prompt = """
Trigger @codex review (idempotent — skip if already commented on this HEAD),
then poll for bot response with bounded timeout (max 10 min, 30s interval).
If bot times out, set BOT_UNAVAILABLE and fall through — local review
(Step 2) already covers main...HEAD. On timeout, run fallback local review:
csa review --range main...HEAD.

```bash
# --- Trigger @codex review (idempotent) ---
CURRENT_SHA="$(git rev-parse HEAD)"
EXISTING=$(gh api "repos/${REPO}/issues/${PR_NUM}/comments" \\
  --jq "[.[] | select(.body | test(\\"@codex review\\")) | select(.body | test(\\"${CURRENT_SHA}\\") or (.updated_at > \\"$(git log -1 --format=%cI HEAD~1 2>/dev/null || echo 1970-01-01)\\"))] | length" 2>/dev/null || echo "0")
if [ "${EXISTING}" = "0" ]; then
  gh pr comment "${PR_NUM}" --repo "${REPO}" --body "@codex review"
fi

# --- Poll for bot response (max 10 min) ---
BOT_UNAVAILABLE=true
POLL_INTERVAL=30
MAX_WAIT=600
WAITED=0
while [ "${WAITED}" -lt "${MAX_WAIT}" ]; do
  sleep "${POLL_INTERVAL}"
  WAITED=$((WAITED + POLL_INTERVAL))
  BOT_REPLY=$(gh api "repos/${REPO}/issues/${PR_NUM}/comments" \\
    --jq "[.[] | select(.user.type == \\"Bot\\" or .user.login == \\"codex[bot]\\" or .user.login == \\"codex-bot\\") | select(.created_at > \\"$(git log -1 --format=%cI HEAD)\\")] | length" 2>/dev/null || echo "0")
  if [ "${BOT_REPLY}" -gt 0 ] 2>/dev/null; then
    BOT_UNAVAILABLE=false
    break
  fi
  echo "Polling... ${WAITED}s / ${MAX_WAIT}s"
done

if [ "${BOT_UNAVAILABLE}" = "true" ]; then
  echo "Bot timed out after ${MAX_WAIT}s. Falling back to local review."
  csa review --range main...HEAD 2>/dev/null || true
fi
```"""
on_fail = "skip"

[[workflow.steps]]
id = 7
title = "Step 6a: Merge Without Bot"
tool = "bash"
prompt = """
Bot unavailable. Local review already guarantees coverage.
Proceed to merge directly.

```bash
gh pr merge "${PR_NUM}" --repo "${REPO}" --squash --delete-branch
git checkout main && git pull origin main
```"""
on_fail = "abort"
condition = "${BOT_UNAVAILABLE}"

[[workflow.steps]]
id = 8
title = "Evaluate Each Bot Comment"
tool = "claude-code"
prompt = """
Classify each bot review comment on PR #${PR_NUM} as:
- Category A (already fixed): the issue was addressed in subsequent commits
- Category B (suspected false positive): the bot misunderstood the code or context
- Category C (real issue): a genuine problem that needs fixing

For each comment, read the referenced code at the current HEAD and compare with
the bot's suggestion. Output a classification table with reasoning."""
tier = "tier-3-complex"
on_fail = "abort"
condition = "(!(${BOT_UNAVAILABLE})) && (${BOT_HAS_ISSUES})"

[[workflow.steps]]
id = 9
title = "Staleness Filter"
tool = "bash"
prompt = """
For each bot comment, check if the referenced code has been modified since the
comment was posted. Compare comment file paths and line ranges against the latest
HEAD diff (git diff main...HEAD). Comments that reference lines/hunks modified
after the comment timestamp are marked as COMMENT_IS_STALE. Stale comments are
skipped before arbitration — they do not enter the debate step.

```bash
# For each comment: extract file path and line range from bot comment body.
# Compare against: git log --since="${COMMENT_TIMESTAMP}" --oneline -- "${FILE}"
# If file/lines changed after comment: mark COMMENT_IS_STALE=true
# Stale comments are reclassified as Category A (already addressed).
```"""
on_fail = "skip"
condition = "(!(${BOT_UNAVAILABLE})) && (${BOT_HAS_ISSUES})"

[workflow.steps.loop_var]
variable = "comment"
collection = "${BOT_COMMENTS}"

[[workflow.steps]]
id = 10
title = "Arbitrate via Debate"
tool = "csa"
prompt = """
Evaluate this bot review comment independently to determine if it is a
false positive or a real issue.

Read the referenced code at the current HEAD. Consider:
1. Does the code actually have the problem the bot describes?
2. Is the bot's suggestion appropriate for this context?
3. Are there project-specific patterns that justify the current code?

Output: CONFIRMED (real issue) or DISMISSED (false positive) with reasoning.
Post the full audit trail as a PR comment."""
tier = "tier-2-standard"
on_fail = "abort"
condition = "(!(${BOT_UNAVAILABLE})) && ((${BOT_HAS_ISSUES}) && ((${COMMENT_IS_FALSE_POSITIVE}) && (!(${COMMENT_IS_STALE}))))"

[workflow.steps.loop_var]
variable = "comment"
collection = "${BOT_COMMENTS}"

[[workflow.steps]]
id = 11
title = "Fix Real Issue"
tool = "csa"
prompt = "Fix the real issue. Commit the fix."
tier = "tier-2-standard"
condition = "(!(${BOT_UNAVAILABLE})) && ((${BOT_HAS_ISSUES}) && (!(${COMMENT_IS_FALSE_POSITIVE})) && (!(${COMMENT_IS_STALE})))"

[workflow.steps.on_fail]
retry = 2

[workflow.steps.loop_var]
variable = "comment"
collection = "${BOT_COMMENTS}"

[[workflow.steps]]
id = 12
title = "Push Fixes and Re-trigger"
tool = "bash"
prompt = """
```bash
git push origin "${WORKFLOW_BRANCH}"
gh pr comment "${PR_NUM}" --repo "${REPO}" --body "@codex review"
```

Loop back to Step 5 (poll). Max 10 total iterations."""
on_fail = "abort"
condition = "(!(${BOT_UNAVAILABLE})) && (${BOT_HAS_ISSUES})"

[[workflow.steps]]
id = 13
title = "Step 10a: Bot Review Clean"
prompt = "No issues found by bot. Proceed to merge."
on_fail = "abort"
condition = "(!(${BOT_UNAVAILABLE})) && (!(${BOT_HAS_ISSUES}))"

[[workflow.steps]]
id = 14
title = "Clean Resubmission (if needed)"
tool = "bash"
prompt = """
If fixes accumulated, create clean branch for final review.

```bash
CLEAN_BRANCH="${WORKFLOW_BRANCH}-clean"
git checkout -b "${CLEAN_BRANCH}"
git push -u origin "${CLEAN_BRANCH}"
gh pr create --base main --head "${CLEAN_BRANCH}" --title "${PR_TITLE}" --body "${PR_BODY}"
```"""
on_fail = "abort"
condition = "(!(${BOT_UNAVAILABLE})) && (${FIXES_ACCUMULATED})"

[[workflow.steps]]
id = 15
title = "Final Merge"
tool = "bash"
prompt = """
Squash-merge and update local main.

```bash
gh pr merge "${WORKFLOW_BRANCH}-clean" --repo "${REPO}" --squash --delete-branch
git checkout main && git pull origin main
```"""
on_fail = "abort"
condition = "(!(${BOT_UNAVAILABLE})) && (${FIXES_ACCUMULATED})"

[[workflow.steps]]
id = 16
title = "Step 12b: Final Merge (Direct)"
tool = "bash"
prompt = """
First-pass clean review: merge the existing PR directly.

```bash
gh pr merge "${PR_NUM}" --repo "${REPO}" --squash --delete-branch
git checkout main && git pull origin main
```"""
on_fail = "abort"
condition = "(!(${BOT_UNAVAILABLE})) && (!(${FIXES_ACCUMULATED}))"
