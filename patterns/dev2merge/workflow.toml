[workflow]
name = "dev2merge"
description = "Full development cycle from branch creation through mktd planning, commit, PR, codex-bot review, and merge"

[[workflow.variables]]
name = "AUDIT_OUTPUT"

[[workflow.variables]]
name = "AUDIT_PROMPT"

[[workflow.variables]]
name = "AUDIT_STATUS"

[[workflow.variables]]
name = "BOT_INLINE_COMMENTS"

[[workflow.variables]]
name = "BOT_PR_COMMENTS"

[[workflow.variables]]
name = "BOT_PR_FINDINGS"

[[workflow.variables]]
name = "BOT_REVIEWS"

[[workflow.variables]]
name = "BOT_REVIEW_FINDINGS"

[[workflow.variables]]
name = "BOT_TRIGGER_REACTIONS"

[[workflow.variables]]
name = "BRANCH"

[[workflow.variables]]
name = "COMMENTS_PAYLOAD"

[[workflow.variables]]
name = "COMMENT_BODY"

[[workflow.variables]]
name = "COMMENT_URL"

[[workflow.variables]]
name = "COMMIT_MSG_LOCAL"

[[workflow.variables]]
name = "ELAPSED"

[[workflow.variables]]
name = "LOCAL_REVIEW_OUTPUT"

[[workflow.variables]]
name = "LOCAL_REVIEW_STATUS"

[[workflow.variables]]
name = "MATCHED_LOCKFILES"

[[workflow.variables]]
name = "ORIGIN_URL"

[[workflow.variables]]
name = "PRE_DIRTY_CARGO_LOCK"

[[workflow.variables]]
name = "PR_BODY_LOCAL"

[[workflow.variables]]
name = "PR_NUM"

[[workflow.variables]]
name = "PR_NUM_FROM_STEP"

[[workflow.variables]]
name = "PR_NUM_LOCAL"

[[workflow.variables]]
name = "REPO_LOCAL"

[[workflow.variables]]
name = "REVIEW_HAS_ISSUES"

[[workflow.variables]]
name = "SCOPE"

[[workflow.variables]]
name = "SELF_LOGIN"

[[workflow.variables]]
name = "STAGED_FILES"

[[workflow.variables]]
name = "STEP_22_OUTPUT"

[[workflow.variables]]
name = "STEP_28_OUTPUT"

[[workflow.variables]]
name = "TIMEOUT"

[[workflow.variables]]
name = "TRIGGER_COMMENT_ID"

[[workflow.variables]]
name = "TRIGGER_TS"

[[workflow.variables]]
name = "VERDICT"

[[workflow.variables]]
name = "VERSION"

[[workflow.variables]]
name = "dir"

[[workflow.variables]]
name = "file"

[[workflow.variables]]
name = "lockpath"

[[workflow.variables]]
name = "source"

[[workflow.variables]]
name = "ts"

[[workflow.steps]]
id = 1
title = "Validate Branch"
tool = "bash"
prompt = """
Verify the current branch is a feature branch, not a protected branch.
If on main or dev, abort immediately.

```bash
BRANCH="$(git branch --show-current)"
if [ -z "${BRANCH}" ] || [ "${BRANCH}" = "HEAD" ]; then
  echo "ERROR: Cannot determine current branch."
  exit 1
fi
DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
if [ -z "$DEFAULT_BRANCH" ]; then DEFAULT_BRANCH="main"; fi
if [ "$BRANCH" = "$DEFAULT_BRANCH" ] || [ "$BRANCH" = "dev" ]; then
  echo "ERROR: Cannot work directly on $BRANCH. Create a feature branch."
  exit 1
fi
```"""
on_fail = "abort"

[[workflow.steps]]
id = 2
title = "Step 1.5: Plan with mktd (Debate Required)"
tool = "bash"
prompt = """
Generate or refresh a branch TODO plan through `mktd` before development gates.
This step MUST pass through mktd's built-in debate phase and save a TODO."""
on_fail = "abort"

[[workflow.steps]]
id = 3
title = "Include mktd"
tool = "weave"
prompt = "mktd"
on_fail = "abort"

[[workflow.steps]]
id = 4
title = "Run Formatters"
tool = "bash"
prompt = """
Run the project formatter to ensure consistent code style.

```bash
just fmt
```"""

[workflow.steps.on_fail]
retry = 2

[[workflow.steps]]
id = 5
title = "Run Linters"
tool = "bash"
prompt = """
Run linters to catch static analysis issues.

```bash
just clippy
```"""

[workflow.steps.on_fail]
retry = 2

[[workflow.steps]]
id = 6
title = "Run Tests"
tool = "bash"
prompt = """
Run the full test suite. All tests must pass before proceeding.

```bash
just test
```"""
on_fail = "abort"

[[workflow.steps]]
id = 7
title = "Stage Changes"
tool = "bash"
prompt = '''
Stage all modified and new files relevant to ${SCOPE}.
Verify no untracked files remain.

```bash
git add -A
if ! printf '%s' "${SCOPE:-}" | grep -Eqi 'release|version|lock|deps|dependency'; then
  STAGED_FILES="$(git diff --cached --name-only)"
  if printf '%s\n' "${STAGED_FILES}" | grep -Eq '(^|/)Cargo[.]toml$|(^|/)package[.]json$|(^|/)pnpm-workspace[.]yaml$|(^|/)go[.]mod$'; then
    echo "INFO: Dependency manifest change detected; preserving staged lockfiles."
  elif ! printf '%s\n' "${STAGED_FILES}" | grep -Ev '(^|/)(Cargo[.]lock|package-lock[.]json|pnpm-lock[.]yaml|yarn[.]lock|go[.]sum)$' | grep -q .; then
    echo "INFO: Lockfile-only staged change detected; preserving staged lockfiles."
  else
    MATCHED_LOCKFILES="$(printf '%s\n' "${STAGED_FILES}" | grep -E '(^|/)(Cargo[.]lock|package-lock[.]json|pnpm-lock[.]yaml|yarn[.]lock|go[.]sum)$' || true)"
    if [ -n "${MATCHED_LOCKFILES}" ]; then
      printf '%s\n' "${MATCHED_LOCKFILES}" | while read -r lockpath; do
        echo "INFO: Unstaging incidental lockfile change: ${lockpath}"
        git restore --staged -- "${lockpath}"
      done
    fi
  fi
fi
if ! git diff --cached --name-only | grep -q .; then
  echo "ERROR: No staged files remain after scope filtering."
  exit 1
fi
if git ls-files --others --exclude-standard | grep -q .; then
  echo "ERROR: Untracked files detected."
  git ls-files --others --exclude-standard
  exit 1
fi
```'''
on_fail = "abort"

[[workflow.steps]]
id = 8
title = "Security Scan"
tool = "bash"
prompt = """
Check for hardcoded secrets, debug statements, and commented-out code
in staged files. Runs after staging so `git diff --cached` covers all changes.

```bash
git diff --cached --name-only | while read -r file; do
  if grep -nE '(API_KEY|SECRET|PASSWORD|PRIVATE_KEY)=' "$file" 2>/dev/null; then
    echo "FAIL: Potential secret in $file"
    exit 1
  fi
done
```"""
on_fail = "abort"

[[workflow.steps]]
id = 9
title = "Security Audit"
tool = "bash"
prompt = '''
Run the security-audit skill: test completeness check, vulnerability scan,
and code quality check. The audit MUST pass before commit.

Phase 1: Can you propose a test case that does not exist? If yes, FAIL.
Phase 2: Input validation, size limits, panic risks.
Phase 3: No debug code, secrets, or commented-out code.

```bash
AUDIT_PROMPT="Use the security-audit skill.
Run security-audit against staged changes.
Output a concise report and end with EXACTLY one line:
SECURITY_AUDIT_VERDICT: PASS|PASS_DEFERRED|FAIL"
if command -v timeout >/dev/null 2>&1; then
  AUDIT_OUTPUT="$(timeout 1200 csa run --skill security-audit "${AUDIT_PROMPT}" 2>&1)"
  AUDIT_STATUS=$?
else
  AUDIT_OUTPUT="$(csa run --skill security-audit "${AUDIT_PROMPT}" 2>&1)"
  AUDIT_STATUS=$?
fi
printf '%s\n' "${AUDIT_OUTPUT}"
if [ "${AUDIT_STATUS}" -eq 124 ]; then
  echo "ERROR: security-audit timed out after 1200s." >&2
  exit 1
fi
if [ "${AUDIT_STATUS}" -ne 0 ]; then
  echo "ERROR: security-audit command failed (exit=${AUDIT_STATUS})." >&2
  exit 1
fi
VERDICT="$(printf '%s\n' "${AUDIT_OUTPUT}" | sed -nE 's/^SECURITY_AUDIT_VERDICT:[[:space:]]*(PASS_DEFERRED|PASS|FAIL)$/\1/p' | tail -n1)"
if [ -z "${VERDICT}" ]; then
  echo "ERROR: Missing SECURITY_AUDIT_VERDICT marker in audit output." >&2
  exit 1
fi
if [ "${VERDICT}" = "FAIL" ]; then
  echo "ERROR: security-audit verdict is FAIL." >&2
  exit 1
fi
echo "SECURITY_AUDIT_VERDICT=${VERDICT}"
```'''
on_fail = "abort"

[[workflow.steps]]
id = 10
title = "Pre-Commit Review"
tool = "csa"
prompt = """
Run heterogeneous code review on all uncommitted changes versus HEAD.
The reviewer MUST be a different model family than the code author.

```bash
csa review --diff
```

Review output includes AGENTS.md compliance checklist."""
tier = "tier-2-standard"
on_fail = "abort"

[[workflow.steps]]
id = 11
title = "Fix Review Issues"
tool = "csa"
prompt = """
Fix each issue identified by the pre-commit review.
Preserve original code intent. Do NOT delete code to silence warnings.
Before applying fixes, write a reflection note to
`drafts/issues/<date --iso-8601=seconds>/review-reflection.md` classifying root
cause as `RULE_GAP`, `WORKFLOW_GAP`, or `EXECUTION_GAP`."""
tier = "tier-2-standard"
condition = "${REVIEW_HAS_ISSUES}"

[workflow.steps.on_fail]
retry = 3

[[workflow.steps]]
id = 12
title = "Re-run Quality Gates"
tool = "bash"
prompt = """
Re-run formatters, linters, and tests after fixes.

```bash
just pre-commit
```"""
on_fail = "abort"
condition = "${REVIEW_HAS_ISSUES}"

[[workflow.steps]]
id = 13
title = "Re-review"
tool = "csa"
prompt = """
Run `csa review --diff` again to verify all issues are resolved.
Loop back to Step 9 if issues persist (max 3 rounds)."""
tier = "tier-2-standard"
on_fail = "abort"
condition = "${REVIEW_HAS_ISSUES}"

[[workflow.steps]]
id = 14
title = "Generate Commit Message"
tool = "bash"
prompt = """
Generate a deterministic Conventional Commits message from staged files.

```bash
scripts/gen_commit_msg.sh "${SCOPE:-}"
```"""
on_fail = "abort"

[[workflow.steps]]
id = 15
title = "Commit"
tool = "bash"
prompt = """
Create the commit using the generated message from Step 12.

```bash
COMMIT_MSG_LOCAL="${STEP_12_OUTPUT:-${COMMIT_MSG:-}}"
if [ -z "${COMMIT_MSG_LOCAL}" ]; then
  echo "ERROR: Commit message is empty. Step 12 must output a commit message." >&2
  exit 1
fi
git commit -m "${COMMIT_MSG_LOCAL}"
```"""
on_fail = "abort"

[[workflow.steps]]
id = 16
title = "Ensure Version Bumped"
tool = "bash"
prompt = """
Ensure workspace version differs from main before push gate.
If not bumped yet, auto-bump patch and create a dedicated release commit.

```bash
set -euo pipefail
if just check-version-bumped; then
  echo "Version bump check passed."
  exit 0
fi
PRE_DIRTY_CARGO_LOCK=0
if git diff --name-only -- Cargo.lock | grep -q .; then
  PRE_DIRTY_CARGO_LOCK=1
fi
just bump-patch
# Use workspace weave binary to avoid stale globally-installed version drift.
cargo run -p weave -- lock
git add Cargo.toml weave.lock
if [ "${PRE_DIRTY_CARGO_LOCK}" -eq 0 ] && [ -f Cargo.lock ]; then
  git add Cargo.lock
else
  echo "INFO: Skipping Cargo.lock in release commit (pre-existing local edits)."
fi
if git diff --cached --quiet; then
  echo "ERROR: Version bump expected changes but none were staged." >&2
  exit 1
fi
VERSION="$(cargo metadata --no-deps --format-version 1 | jq -r '.packages[] | select(.name == "cli-sub-agent") | .version')"
git commit -m "chore(release): bump workspace version to ${VERSION}"
```"""
on_fail = "abort"

[[workflow.steps]]
id = 17
title = "Pre-PR Cumulative Review"
tool = "csa"
prompt = """
Run a cumulative review covering ALL commits on the feature branch since main.
This is distinct from Step 8's per-commit review (`csa review --diff`):
- Step 8 reviews uncommitted changes (staged diff) — single-commit granularity.
- This step reviews the full feature branch — catches cross-commit issues.

MANDATORY: This review MUST pass before pushing to origin.

```bash
csa review --range main...HEAD
CUMULATIVE_REVIEW_COMPLETED=true
```"""
tier = "tier-2-standard"
on_fail = "abort"

[[workflow.steps]]
id = 18
title = "Push to Origin"
tool = "bash"
prompt = """
Push the feature branch to the remote origin.

```bash
BRANCH="$(git branch --show-current)"
if [ -z "${BRANCH}" ] || [ "${BRANCH}" = "HEAD" ]; then
  echo "ERROR: Cannot determine current branch for push."
  exit 1
fi
git push -u origin "${BRANCH}"
```"""

[workflow.steps.on_fail]
retry = 2

[[workflow.steps]]
id = 19
title = "Create Pull Request"
tool = "bash"
prompt = '''
Create a PR targeting main via GitHub CLI. The PR body includes a summary
of changes for ${SCOPE} and a test plan checklist covering tests, linting,
security audit, and codex review.

```bash
REPO_LOCAL="$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || true)"
if [ -z "${REPO_LOCAL}" ]; then
  ORIGIN_URL="$(git remote get-url origin 2>/dev/null || true)"
  REPO_LOCAL="$(printf '%s' "${ORIGIN_URL}" | sed -nE 's#(git@github\.com:|https://github\.com/)([^/]+/[^/]+)(\.git)?$#\2#p')"
  REPO_LOCAL="${REPO_LOCAL%.git}"
fi
if [ -z "${REPO_LOCAL}" ]; then
  echo "ERROR: Cannot resolve repository owner/name." >&2
  exit 1
fi
COMMIT_MSG_LOCAL="${STEP_12_OUTPUT:-${COMMIT_MSG:-}}"
if [ -z "${COMMIT_MSG_LOCAL}" ]; then
  echo "ERROR: PR title is empty. Step 12 output is required." >&2
  exit 1
fi
PR_BODY_LOCAL="${PR_BODY:-## Summary
- Scope: ${SCOPE:-unspecified}'''
on_fail = "abort"

[[workflow.steps]]
id = 20
title = "Validation"
prompt = """
- just fmt
- just clippy
- just test
- csa review --range main...HEAD
}"
gh pr create --base main --repo "${REPO_LOCAL}" --title "${COMMIT_MSG_LOCAL}" --body "${PR_BODY_LOCAL}"
```"""
on_fail = "abort"

[[workflow.steps]]
id = 21
title = "Trigger Codex Bot Review"
tool = "bash"
prompt = '''
Trigger the cloud codex review bot on the newly created PR.
Capture the PR number for polling.

```bash
set -euo pipefail
REPO_LOCAL="$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || true)"
if [ -z "${REPO_LOCAL}" ]; then
  ORIGIN_URL="$(git remote get-url origin 2>/dev/null || true)"
  REPO_LOCAL="$(printf '%s' "${ORIGIN_URL}" | sed -nE 's#(git@github\.com:|https://github\.com/)([^/]+/[^/]+)(\.git)?$#\2#p')"
  REPO_LOCAL="${REPO_LOCAL%.git}"
fi
if [ -z "${REPO_LOCAL}" ]; then
  echo "ERROR: Cannot resolve repository owner/name." >&2
  exit 1
fi
PR_NUM=$(gh pr view --json number -q '.number')
COMMENT_URL="$(gh pr comment "${PR_NUM}" --repo "${REPO_LOCAL}" --body "@codex review")"
SELF_LOGIN=$(gh api user -q '.login')
COMMENTS_PAYLOAD=$(gh api "repos/${REPO_LOCAL}/issues/${PR_NUM}/comments?per_page=100")
TRIGGER_TS=$(printf '%s' "${COMMENTS_PAYLOAD}" | jq -r --arg me "${SELF_LOGIN}" '[.[]? | select((.user.login // "") == $me and (.body // "") == "@codex review")] | sort_by(.created_at) | last | .created_at // empty')
TRIGGER_COMMENT_ID=$(printf '%s' "${COMMENT_URL}" | sed -nE 's#.*issuecomment-([0-9]+).*#\1#p')
if [ -z "${TRIGGER_COMMENT_ID}" ]; then
  TRIGGER_COMMENT_ID=$(printf '%s' "${COMMENTS_PAYLOAD}" | jq -r --arg me "${SELF_LOGIN}" '[.[]? | select((.user.login // "") == $me and (.body // "") == "@codex review")] | sort_by(.created_at) | last | .id // empty')
fi
if [ -z "${TRIGGER_TS}" ]; then
  TRIGGER_TS=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
fi
printf 'PR_NUM=%s\nTRIGGER_TS=%s\nTRIGGER_COMMENT_ID=%s\n' "${PR_NUM}" "${TRIGGER_TS}" "${TRIGGER_COMMENT_ID}"
```'''
on_fail = "abort"

[[workflow.steps]]
id = 22
title = "Poll for Bot Response"
tool = "bash"
prompt = '''
Poll for bot review response with a bounded timeout (max 20 minutes).
Output `1` when actionable findings are present; output empty string when clean.
If cloud review times out, run local heterogeneous fallback review on
`main...HEAD`; clean fallback posts an English PR comment then returns clean.

```bash
set -euo pipefail
TIMEOUT=1200; INTERVAL=30; ELAPSED=0
REPO_LOCAL="$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || true)"
if [ -z "${REPO_LOCAL}" ]; then
  ORIGIN_URL="$(git remote get-url origin 2>/dev/null || true)"
  REPO_LOCAL="$(printf '%s' "${ORIGIN_URL}" | sed -nE 's#(git@github\.com:|https://github\.com/)([^/]+/[^/]+)(\.git)?$#\2#p')"
  REPO_LOCAL="${REPO_LOCAL%.git}"
fi
if [ -z "${REPO_LOCAL}" ]; then
  echo "ERROR: Cannot resolve repository owner/name." >&2
  exit 1
fi
PR_NUM_FROM_STEP="$(printf '%s\n' "${STEP_21_OUTPUT:-}" | sed -n 's/^PR_NUM=//p' | tail -n1)"
TRIGGER_TS="$(printf '%s\n' "${STEP_21_OUTPUT:-}" | sed -n 's/^TRIGGER_TS=//p' | tail -n1)"
TRIGGER_COMMENT_ID="$(printf '%s\n' "${STEP_21_OUTPUT:-}" | sed -n 's/^TRIGGER_COMMENT_ID=//p' | tail -n1)"
if [ -z "${PR_NUM_FROM_STEP}" ]; then PR_NUM_FROM_STEP="${PR_NUM}"; fi
if [ -z "${TRIGGER_TS}" ]; then TRIGGER_TS="1970-01-01T00:00:00Z"; fi
write_reflection_issue() {
  local source="$1"
  local ts
  ts="$(date --iso-8601=seconds)"
  local dir="drafts/issues/${ts}"
  mkdir -p "${dir}"
  local file="${dir}/review-reflection.md"
  cat > "${file}" <<EOF
# Review Finding Reflection
- Timestamp: ${ts}
- Source: ${source}
- Branch: $(git branch --show-current)
- PR: ${PR_NUM_FROM_STEP}
- Review Range: main...HEAD

Why this issue escaped earlier checks:
- Rule gap candidate: CLAUDE.md / AGENTS.md / .agents/rules-ref missing enforceable guidance.
- Workflow gap candidate: csa hook/dev2merge missing mandatory guardrails.
- Execution gap candidate: existing rules were present but not followed during implementation.

Mandatory follow-up before merge:
- [ ] Classify each finding into one root-cause bucket above.
- [ ] If rule gap: patch CLAUDE.md, AGENTS.md, or .agents/rules-ref in the fix stream.
- [ ] If workflow gap: patch csa hook/workflow and add verification.
- [ ] If execution gap: add stronger checklist/tests to prevent recurrence.
- [ ] Re-run heterogeneous review on main...HEAD and confirm clean.
EOF
  echo "REFLECTION_ISSUE_PATH=${file}" >&2
}
while [ "$ELAPSED" -lt "$TIMEOUT" ]; do
  BOT_INLINE_COMMENTS=$(gh api "repos/${REPO_LOCAL}/pulls/${PR_NUM_FROM_STEP}/comments?per_page=100" | jq -r --arg ts "${TRIGGER_TS}" '[.[]? | select(.created_at >= $ts and (.user.login | ascii_downcase | test("codex|bot|connector")))] | length')
  BOT_PR_COMMENTS=$(gh api "repos/${REPO_LOCAL}/issues/${PR_NUM_FROM_STEP}/comments?per_page=100" | jq -r --arg ts "${TRIGGER_TS}" '[.[]? | select((.created_at // "") >= $ts and (.user.login | ascii_downcase | test("codex|bot|connector")) and (((.body // "") | ascii_downcase | contains("@codex review")) | not))] | length')
  BOT_PR_FINDINGS=$(gh api "repos/${REPO_LOCAL}/issues/${PR_NUM_FROM_STEP}/comments?per_page=100" | jq -r --arg ts "${TRIGGER_TS}" '[.[]? | select((.created_at // "") >= $ts and (.user.login | ascii_downcase | test("codex|bot|connector")) and (((.body // "") | ascii_downcase | contains("@codex review")) | not) and ((.body // "") | ascii_downcase | test("(^|[^a-z0-9])p[0-3]([^a-z0-9]|$)|changes requested|must fix|blocking|severity|critical")))] | length')
  BOT_REVIEWS=$(gh api "repos/${REPO_LOCAL}/pulls/${PR_NUM_FROM_STEP}/reviews?per_page=100" | jq -r --arg ts "${TRIGGER_TS}" '[.[]? | select((.submitted_at // "") >= $ts and (.user.login | ascii_downcase | test("codex|bot|connector")))] | length')
  BOT_REVIEW_FINDINGS=$(gh api "repos/${REPO_LOCAL}/pulls/${PR_NUM_FROM_STEP}/reviews?per_page=100" | jq -r --arg ts "${TRIGGER_TS}" '[.[]? | select((.submitted_at // "") >= $ts and (.user.login | ascii_downcase | test("codex|bot|connector")) and ((((.state // "") | ascii_downcase) == "changes_requested") or ((.body // "") | ascii_downcase | test("(^|[^a-z0-9])p[0-3]([^a-z0-9]|$)|changes requested|must fix|blocking|severity|critical"))))] | length')
  BOT_TRIGGER_REACTIONS=0
  if [ -n "${TRIGGER_COMMENT_ID}" ]; then
    BOT_TRIGGER_REACTIONS=$(gh api "repos/${REPO_LOCAL}/issues/comments/${TRIGGER_COMMENT_ID}/reactions?per_page=100" -H "Accept: application/vnd.github+json" | jq -r '[.[]? | select((.user.login | ascii_downcase | test("codex|bot|connector")))] | length')
  fi
  echo "heartbeat elapsed=${ELAPSED}s inline=${BOT_INLINE_COMMENTS} pr_comments=${BOT_PR_COMMENTS} pr_findings=${BOT_PR_FINDINGS} reviews=${BOT_REVIEWS} review_findings=${BOT_REVIEW_FINDINGS} reactions=${BOT_TRIGGER_REACTIONS}" >&2
  if [ "${BOT_INLINE_COMMENTS}" -gt 0 ] || [ "${BOT_PR_FINDINGS}" -gt 0 ] || [ "${BOT_REVIEW_FINDINGS}" -gt 0 ]; then
    write_reflection_issue "cloud-bot-initial"
    echo "1"
    exit 0
  fi
  if [ "${BOT_PR_COMMENTS}" -gt 0 ] || [ "${BOT_REVIEWS}" -gt 0 ] || [ "${BOT_TRIGGER_REACTIONS}" -gt 0 ]; then
    echo ""
    exit 0
  fi
  sleep "$INTERVAL"
  ELAPSED=$((ELAPSED + INTERVAL))
done
echo "INFO: Timed out waiting for cloud bot response after ${TIMEOUT}s; running local fallback review." >&2
set +e
LOCAL_REVIEW_OUTPUT="$(csa review --range main...HEAD --tool auto 2>&1)"
LOCAL_REVIEW_STATUS=$?
set -e
printf '%s\n' "${LOCAL_REVIEW_OUTPUT}" >&2
if [ "${LOCAL_REVIEW_STATUS}" -eq 0 ]; then
  COMMENT_BODY="Cloud Codex review timed out after 20 minutes. I completed a comprehensive local heterogeneous review on main...HEAD with no blocking findings, so I will merge directly."
  gh pr comment "${PR_NUM_FROM_STEP}" --repo "${REPO_LOCAL}" --body "${COMMENT_BODY}" >/dev/null
  echo ""
  exit 0
fi
if printf '%s\n' "${LOCAL_REVIEW_OUTPUT}" | grep -Eqi '(^|[^A-Za-z0-9_])HAS_ISSUES([^A-Za-z0-9_]|$)|final_decision:[[:space:]]*HAS_ISSUES'; then
  write_reflection_issue "local-fallback-after-cloud-timeout"
  echo "1"
  exit 0
fi
echo "ERROR: Local fallback review failed unexpectedly (exit=${LOCAL_REVIEW_STATUS})." >&2
exit "${LOCAL_REVIEW_STATUS}"
```'''
on_fail = "abort"

[[workflow.steps]]
id = 23
title = "Evaluate Review Findings and Root Cause"
tool = "csa"
prompt = """
Evaluate findings from cloud bot comments and/or local fallback review output,
then produce a consolidated action plan.
For each confirmed finding, classify root cause into exactly one bucket:
- `RULE_GAP`: CLAUDE.md / AGENTS.md / .agents/rules-ref lacks enforceable rule(s).
- `WORKFLOW_GAP`: csa hook/workflow lacks required enforcement.
- `EXECUTION_GAP`: rules existed, but implementation/review did not follow them.
List suspected false positives and confirmed defects separately."""
tier = "tier-2-standard"
on_fail = "abort"
condition = "${STEP_22_OUTPUT}"

[[workflow.steps]]
id = 24
title = "Arbitrate Disputed Findings"
tool = "csa"
prompt = """
For disputed findings, run independent arbitration using `csa debate` and
produce a verdict for each disputed item."""
on_fail = "abort"
condition = "${STEP_22_OUTPUT}"

[[workflow.steps]]
id = 25
title = "Fix Confirmed Issues"
tool = "csa"
prompt = """
Implement fixes for confirmed findings and create commit(s) with clear
messages. Do not modify unrelated files.
If root cause was `RULE_GAP` or `WORKFLOW_GAP`, include corresponding rule/hook
workflow updates in the same fix stream."""
tier = "tier-2-standard"
on_fail = "abort"
condition = "${STEP_22_OUTPUT}"

[[workflow.steps]]
id = 26
title = "Re-run Local Review After Fixes"
tool = "csa"
prompt = "Run `csa review --diff` to validate fixes before re-triggering cloud review."
tier = "tier-2-standard"
condition = "${STEP_22_OUTPUT}"

[workflow.steps.on_fail]
retry = 2

[[workflow.steps]]
id = 27
title = "Push Fixes and Re-trigger Review"
tool = "bash"
prompt = '''
Push all fix commits and trigger a new round of codex review.

```bash
set -euo pipefail
REPO_LOCAL="$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || true)"
if [ -z "${REPO_LOCAL}" ]; then
  ORIGIN_URL="$(git remote get-url origin 2>/dev/null || true)"
  REPO_LOCAL="$(printf '%s' "${ORIGIN_URL}" | sed -nE 's#(git@github\.com:|https://github\.com/)([^/]+/[^/]+)(\.git)?$#\2#p')"
  REPO_LOCAL="${REPO_LOCAL%.git}"
fi
if [ -z "${REPO_LOCAL}" ]; then
  echo "ERROR: Cannot resolve repository owner/name." >&2
  exit 1
fi
BRANCH="$(git branch --show-current)"
if [ -z "${BRANCH}" ] || [ "${BRANCH}" = "HEAD" ]; then
  echo "ERROR: Cannot determine current branch for push."
  exit 1
fi
git push origin "${BRANCH}"
PR_NUM_LOCAL="$(printf '%s\n' "${STEP_21_OUTPUT:-}" | sed -n 's/^PR_NUM=//p' | tail -n1)"
if [ -z "${PR_NUM_LOCAL}" ]; then
  PR_NUM_LOCAL="$(gh pr view --json number -q '.number')"
fi
COMMENT_URL="$(gh pr comment "${PR_NUM_LOCAL}" --repo "${REPO_LOCAL}" --body "@codex review")"
SELF_LOGIN=$(gh api user -q '.login')
COMMENTS_PAYLOAD=$(gh api "repos/${REPO_LOCAL}/issues/${PR_NUM_LOCAL}/comments?per_page=100")
TRIGGER_TS=$(printf '%s' "${COMMENTS_PAYLOAD}" | jq -r --arg me "${SELF_LOGIN}" '[.[]? | select((.user.login // "") == $me and (.body // "") == "@codex review")] | sort_by(.created_at) | last | .created_at // empty')
TRIGGER_COMMENT_ID=$(printf '%s' "${COMMENT_URL}" | sed -nE 's#.*issuecomment-([0-9]+).*#\1#p')
if [ -z "${TRIGGER_COMMENT_ID}" ]; then
  TRIGGER_COMMENT_ID=$(printf '%s' "${COMMENTS_PAYLOAD}" | jq -r --arg me "${SELF_LOGIN}" '[.[]? | select((.user.login // "") == $me and (.body // "") == "@codex review")] | sort_by(.created_at) | last | .id // empty')
fi
if [ -z "${TRIGGER_TS}" ]; then
  TRIGGER_TS=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
fi
printf 'PR_NUM=%s\nTRIGGER_TS=%s\nTRIGGER_COMMENT_ID=%s\n' "${PR_NUM_LOCAL}" "${TRIGGER_TS}" "${TRIGGER_COMMENT_ID}"
```'''
on_fail = "abort"
condition = "${STEP_22_OUTPUT}"

[[workflow.steps]]
id = 28
title = "Poll Re-triggered Bot Response"
tool = "bash"
prompt = '''
After posting the second `@codex review`, poll again with bounded timeout.
Output `1` when findings remain; output empty string when clean.
If cloud review times out again, run local heterogeneous fallback review on
`main...HEAD`; clean fallback posts an English PR comment then returns clean.

```bash
set -euo pipefail
TIMEOUT=1200; INTERVAL=30; ELAPSED=0
REPO_LOCAL="$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || true)"
if [ -z "${REPO_LOCAL}" ]; then
  ORIGIN_URL="$(git remote get-url origin 2>/dev/null || true)"
  REPO_LOCAL="$(printf '%s' "${ORIGIN_URL}" | sed -nE 's#(git@github\.com:|https://github\.com/)([^/]+/[^/]+)(\.git)?$#\2#p')"
  REPO_LOCAL="${REPO_LOCAL%.git}"
fi
if [ -z "${REPO_LOCAL}" ]; then
  echo "ERROR: Cannot resolve repository owner/name." >&2
  exit 1
fi
PR_NUM_FROM_STEP="$(printf '%s\n' "${STEP_27_OUTPUT:-}" | sed -n 's/^PR_NUM=//p' | tail -n1)"
TRIGGER_TS="$(printf '%s\n' "${STEP_27_OUTPUT:-}" | sed -n 's/^TRIGGER_TS=//p' | tail -n1)"
TRIGGER_COMMENT_ID="$(printf '%s\n' "${STEP_27_OUTPUT:-}" | sed -n 's/^TRIGGER_COMMENT_ID=//p' | tail -n1)"
if [ -z "${PR_NUM_FROM_STEP}" ]; then
  PR_NUM_FROM_STEP="$(printf '%s\n' "${STEP_21_OUTPUT:-}" | sed -n 's/^PR_NUM=//p' | tail -n1)"
fi
if [ -z "${PR_NUM_FROM_STEP}" ]; then
  PR_NUM_FROM_STEP="$(gh pr view --json number -q '.number')"
fi
if [ -z "${TRIGGER_TS}" ]; then TRIGGER_TS="1970-01-01T00:00:00Z"; fi
write_reflection_issue() {
  local source="$1"
  local ts
  ts="$(date --iso-8601=seconds)"
  local dir="drafts/issues/${ts}"
  mkdir -p "${dir}"
  local file="${dir}/review-reflection.md"
  cat > "${file}" <<EOF
# Review Finding Reflection
- Timestamp: ${ts}
- Source: ${source}
- Branch: $(git branch --show-current)
- PR: ${PR_NUM_FROM_STEP}
- Review Range: main...HEAD

Why this issue escaped earlier checks:
- Rule gap candidate: CLAUDE.md / AGENTS.md / .agents/rules-ref missing enforceable guidance.
- Workflow gap candidate: csa hook/dev2merge missing mandatory guardrails.
- Execution gap candidate: existing rules were present but not followed during implementation.

Mandatory follow-up before merge:
- [ ] Classify each finding into one root-cause bucket above.
- [ ] If rule gap: patch CLAUDE.md, AGENTS.md, or .agents/rules-ref in the fix stream.
- [ ] If workflow gap: patch csa hook/workflow and add verification.
- [ ] If execution gap: add stronger checklist/tests to prevent recurrence.
- [ ] Re-run heterogeneous review on main...HEAD and confirm clean.
EOF
  echo "REFLECTION_ISSUE_PATH=${file}" >&2
}
while [ "$ELAPSED" -lt "$TIMEOUT" ]; do
  BOT_INLINE_COMMENTS=$(gh api "repos/${REPO_LOCAL}/pulls/${PR_NUM_FROM_STEP}/comments?per_page=100" | jq -r --arg ts "${TRIGGER_TS}" '[.[]? | select(.created_at >= $ts and (.user.login | ascii_downcase | test("codex|bot|connector")))] | length')
  BOT_PR_COMMENTS=$(gh api "repos/${REPO_LOCAL}/issues/${PR_NUM_FROM_STEP}/comments?per_page=100" | jq -r --arg ts "${TRIGGER_TS}" '[.[]? | select((.created_at // "") >= $ts and (.user.login | ascii_downcase | test("codex|bot|connector")) and (((.body // "") | ascii_downcase | contains("@codex review")) | not))] | length')
  BOT_PR_FINDINGS=$(gh api "repos/${REPO_LOCAL}/issues/${PR_NUM_FROM_STEP}/comments?per_page=100" | jq -r --arg ts "${TRIGGER_TS}" '[.[]? | select((.created_at // "") >= $ts and (.user.login | ascii_downcase | test("codex|bot|connector")) and (((.body // "") | ascii_downcase | contains("@codex review")) | not) and ((.body // "") | ascii_downcase | test("(^|[^a-z0-9])p[0-3]([^a-z0-9]|$)|changes requested|must fix|blocking|severity|critical")))] | length')
  BOT_REVIEWS=$(gh api "repos/${REPO_LOCAL}/pulls/${PR_NUM_FROM_STEP}/reviews?per_page=100" | jq -r --arg ts "${TRIGGER_TS}" '[.[]? | select((.submitted_at // "") >= $ts and (.user.login | ascii_downcase | test("codex|bot|connector")))] | length')
  BOT_REVIEW_FINDINGS=$(gh api "repos/${REPO_LOCAL}/pulls/${PR_NUM_FROM_STEP}/reviews?per_page=100" | jq -r --arg ts "${TRIGGER_TS}" '[.[]? | select((.submitted_at // "") >= $ts and (.user.login | ascii_downcase | test("codex|bot|connector")) and ((((.state // "") | ascii_downcase) == "changes_requested") or ((.body // "") | ascii_downcase | test("(^|[^a-z0-9])p[0-3]([^a-z0-9]|$)|changes requested|must fix|blocking|severity|critical"))))] | length')
  BOT_TRIGGER_REACTIONS=0
  if [ -n "${TRIGGER_COMMENT_ID}" ]; then
    BOT_TRIGGER_REACTIONS=$(gh api "repos/${REPO_LOCAL}/issues/comments/${TRIGGER_COMMENT_ID}/reactions?per_page=100" -H "Accept: application/vnd.github+json" | jq -r '[.[]? | select((.user.login | ascii_downcase | test("codex|bot|connector")))] | length')
  fi
  echo "heartbeat elapsed=${ELAPSED}s inline=${BOT_INLINE_COMMENTS} pr_comments=${BOT_PR_COMMENTS} pr_findings=${BOT_PR_FINDINGS} reviews=${BOT_REVIEWS} review_findings=${BOT_REVIEW_FINDINGS} reactions=${BOT_TRIGGER_REACTIONS}" >&2
  if [ "${BOT_INLINE_COMMENTS}" -gt 0 ] || [ "${BOT_PR_FINDINGS}" -gt 0 ] || [ "${BOT_REVIEW_FINDINGS}" -gt 0 ]; then
    write_reflection_issue "cloud-bot-rerun"
    echo "1"
    exit 0
  fi
  if [ "${BOT_PR_COMMENTS}" -gt 0 ] || [ "${BOT_REVIEWS}" -gt 0 ] || [ "${BOT_TRIGGER_REACTIONS}" -gt 0 ]; then
    echo ""
    exit 0
  fi
  sleep "$INTERVAL"
  ELAPSED=$((ELAPSED + INTERVAL))
done
echo "INFO: Timed out waiting for re-triggered cloud review after ${TIMEOUT}s; running local fallback review." >&2
set +e
LOCAL_REVIEW_OUTPUT="$(csa review --range main...HEAD --tool auto 2>&1)"
LOCAL_REVIEW_STATUS=$?
set -e
printf '%s\n' "${LOCAL_REVIEW_OUTPUT}" >&2
if [ "${LOCAL_REVIEW_STATUS}" -eq 0 ]; then
  COMMENT_BODY="Re-triggered cloud Codex review timed out after 20 minutes. I completed a comprehensive local heterogeneous review on main...HEAD with no blocking findings, so I will merge directly."
  gh pr comment "${PR_NUM_FROM_STEP}" --repo "${REPO_LOCAL}" --body "${COMMENT_BODY}" >/dev/null
  echo ""
  exit 0
fi
if printf '%s\n' "${LOCAL_REVIEW_OUTPUT}" | grep -Eqi '(^|[^A-Za-z0-9_])HAS_ISSUES([^A-Za-z0-9_]|$)|final_decision:[[:space:]]*HAS_ISSUES'; then
  write_reflection_issue "local-fallback-after-rerun-timeout"
  echo "1"
  exit 0
fi
echo "ERROR: Local fallback review failed unexpectedly (exit=${LOCAL_REVIEW_STATUS})." >&2
exit "${LOCAL_REVIEW_STATUS}"
```'''
on_fail = "abort"
condition = "${STEP_22_OUTPUT}"

[[workflow.steps]]
id = 29
title = "Stop on Remaining Findings"
tool = "bash"
prompt = """
Abort merge when re-triggered review still reports findings.
Reflection issue artifacts should already be written under `drafts/issues/<timestamp>/`.

```bash
echo "ERROR: Review still has findings after re-trigger. Do not merge." >&2
exit 1
```"""
on_fail = "abort"
condition = "(${STEP_22_OUTPUT}) && (${STEP_28_OUTPUT})"

[[workflow.steps]]
id = 30
title = "Merge PR After Re-review Clean"
tool = "bash"
prompt = '''
Squash-merge the PR after the second bot review returns clean, then update local main.

```bash
REPO_LOCAL="$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || true)"
if [ -z "${REPO_LOCAL}" ]; then
  ORIGIN_URL="$(git remote get-url origin 2>/dev/null || true)"
  REPO_LOCAL="$(printf '%s' "${ORIGIN_URL}" | sed -nE 's#(git@github\.com:|https://github\.com/)([^/]+/[^/]+)(\.git)?$#\2#p')"
  REPO_LOCAL="${REPO_LOCAL%.git}"
fi
if [ -z "${REPO_LOCAL}" ]; then
  echo "ERROR: Cannot resolve repository owner/name." >&2
  exit 1
fi
PR_NUM_LOCAL="$(printf '%s\n' "${STEP_27_OUTPUT:-}" | sed -n 's/^PR_NUM=//p' | tail -n1)"
if [ -z "${PR_NUM_LOCAL}" ]; then
  PR_NUM_LOCAL="$(printf '%s\n' "${STEP_21_OUTPUT:-}" | sed -n 's/^PR_NUM=//p' | tail -n1)"
fi
if [ -z "${PR_NUM_LOCAL}" ]; then
  PR_NUM_LOCAL="$(gh pr view --json number -q '.number')"
fi
gh pr merge "${PR_NUM_LOCAL}" --repo "${REPO_LOCAL}" --squash --delete-branch
git checkout main && git pull origin main
```'''
on_fail = "abort"
condition = "(${STEP_22_OUTPUT}) && (!(${STEP_28_OUTPUT}))"

[[workflow.steps]]
id = 31
title = "Merge PR (Initial Review Clean)"
tool = "bash"
prompt = '''
No issues were found in the initial bot review. Merge using the PR number from step output.

```bash
REPO_LOCAL="$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || true)"
if [ -z "${REPO_LOCAL}" ]; then
  ORIGIN_URL="$(git remote get-url origin 2>/dev/null || true)"
  REPO_LOCAL="$(printf '%s' "${ORIGIN_URL}" | sed -nE 's#(git@github\.com:|https://github\.com/)([^/]+/[^/]+)(\.git)?$#\2#p')"
  REPO_LOCAL="${REPO_LOCAL%.git}"
fi
if [ -z "${REPO_LOCAL}" ]; then
  echo "ERROR: Cannot resolve repository owner/name." >&2
  exit 1
fi
PR_NUM_LOCAL="$(printf '%s\n' "${STEP_21_OUTPUT:-}" | sed -n 's/^PR_NUM=//p' | tail -n1)"
if [ -z "${PR_NUM_LOCAL}" ]; then
  PR_NUM_LOCAL="$(gh pr view --json number -q '.number')"
fi
gh pr merge "${PR_NUM_LOCAL}" --repo "${REPO_LOCAL}" --squash --delete-branch
git checkout main && git pull origin main
```'''
on_fail = "abort"
condition = "!(${STEP_22_OUTPUT})"
