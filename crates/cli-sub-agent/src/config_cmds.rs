use anyhow::Result;
use tracing::{error, warn};

use csa_config::init::init_project;
use csa_config::{GlobalConfig, ProjectConfig, validate_config};
use csa_core::types::OutputFormat;

pub(crate) fn handle_config_show(cd: Option<String>, format: OutputFormat) -> Result<()> {
    let project_root = crate::pipeline::determine_project_root(cd.as_deref())?;
    let config = ProjectConfig::load(&project_root)?
        .ok_or_else(|| anyhow::anyhow!("No configuration found. Run 'csa init' first."))?;

    match format {
        OutputFormat::Json => {
            let json_str = serde_json::to_string_pretty(&config)?;
            println!("{}", json_str);
        }
        OutputFormat::Text => {
            let toml_str = toml::to_string_pretty(&config)?;
            print!("{}", toml_str);
        }
    }
    Ok(())
}

pub(crate) fn handle_config_edit(cd: Option<String>) -> Result<()> {
    let project_root = crate::pipeline::determine_project_root(cd.as_deref())?;
    let config_path = ProjectConfig::config_path(&project_root);

    if !config_path.exists() {
        error!("Configuration file does not exist. Run 'csa init' first.");
        return Ok(());
    }

    let editor = std::env::var("EDITOR").unwrap_or_else(|_| "vi".to_string());
    let status = std::process::Command::new(editor)
        .arg(&config_path)
        .status()?;

    if !status.success() {
        warn!("Editor exited with non-zero status");
    }

    Ok(())
}

pub(crate) fn handle_init(non_interactive: bool, full: bool, template: bool) -> Result<()> {
    let project_root = crate::pipeline::determine_project_root(None)?;

    if template {
        return handle_init_template(&project_root);
    }

    // Default (no flags) = minimal; --full = old default with tool detection.
    let minimal = !full;
    let config = init_project(&project_root, non_interactive, minimal)?;
    eprintln!(
        "Initialized project configuration at: {}",
        ProjectConfig::config_path(&project_root).display()
    );
    eprintln!("Project: {}", config.project.name);
    if minimal {
        eprintln!("  Mode: minimal (tools/tiers inherit from global config)");
        eprintln!("  Use 'csa init --full' to auto-detect tools and generate tiers.");
    }

    // Generate global config if it doesn't exist
    if let Ok(global_path) = GlobalConfig::config_path() {
        if !global_path.exists() {
            match GlobalConfig::save_default_template() {
                Ok(path) => {
                    eprintln!("Generated global config template at: {}", path.display());
                    eprintln!("  Edit to configure API keys and concurrency limits.");
                }
                Err(e) => {
                    warn!("Failed to generate global config: {}", e);
                }
            }
        }
    }

    Ok(())
}

/// Generate a fully-commented TOML template at `.csa/config.toml`.
///
/// All sections are present but commented out, so the config file exists
/// (preventing accidental `csa init` re-runs) while every setting falls
/// through to the global config or built-in defaults.
fn handle_init_template(project_root: &std::path::Path) -> Result<()> {
    let config_path = ProjectConfig::config_path(project_root);
    if config_path.exists() {
        anyhow::bail!("Configuration already exists at {}", config_path.display());
    }

    let project_name = project_root
        .file_name()
        .map(|n| n.to_string_lossy().to_string())
        .unwrap_or_else(|| "unnamed".to_string());
    // Escape the project name for safe TOML embedding (handles quotes, backslashes).
    let escaped_name = project_name.replace('\\', "\\\\").replace('"', "\\\"");

    let template = format!(
        r##"# CSA Project Configuration — generated by `csa init --template`
# Uncomment and edit sections as needed.  Commented-out values fall through
# to the global config (~/.config/cli-sub-agent/config.toml) or built-in defaults.

schema_version = 1

[project]
name = "{escaped_name}"
created_at = "{now}"
max_recursion_depth = 5

# ─── Resources ──────────────────────────────────────────────────
# [resources]
# min_free_memory_mb = 4096
# idle_timeout_seconds = 120
#
# [resources.initial_estimates]
# gemini-cli = 150
# opencode = 500
# codex = 800
# claude-code = 1200

# ─── Resource Sandbox ─────────────────────────────────────────────
# [resources]
# enforcement_mode = "best-effort"   # "required" | "best-effort" | "off"
# memory_max_mb = 8192               # Max RSS per tool process (>= 256)
# memory_swap_max_mb = 4096          # Max swap per tool process
# pids_max = 512                     # Max PIDs per tool process tree (>= 10)

# ─── Tool Configuration ────────────────────────────────────────
# setting_sources: controls which MCP settings to load for ACP-backed tools.
#   [] = load nothing (lean mode), ["project"] = project only, omit = load all.
#
# [tools.codex]
# enabled = true
# suppress_notify = true
#
# [tools.claude-code]
# enabled = true
# suppress_notify = true
# setting_sources = ["project"]    # load only project-level settings
#
# [tools.gemini-cli]
# enabled = true
# suppress_notify = true
# [tools.gemini-cli.restrictions]
# allow_edit_existing_files = false
#
# [tools.opencode]
# enabled = true
# suppress_notify = true

# ─── Model Tiers ───────────────────────────────────────────────
# Format: "tool/provider/model/thinking_budget"
#
# [tiers.tier-1-quick]
# description = "Quick tasks — fast, cheap"
# models = ["codex/openai/gpt-5.3-codex-spark/xhigh"]
#
# [tiers.tier-2-standard]
# description = "Standard tasks"
# models = ["codex/openai/gpt-5.3-codex/high"]
#
# [tiers.tier-3-complex]
# description = "Complex reasoning, architecture, deep analysis"
# models = ["claude-code/anthropic/default/xhigh"]

# ─── Task-to-Tier Mapping ──────────────────────────────────────
# [tier_mapping]
# default = "tier-2-standard"
# architecture_design = "tier-3-complex"
# code_review = "tier-3-complex"
# feature_implementation = "tier-2-standard"
# documentation = "tier-1-quick"
# quick_question = "tier-1-quick"
# security_audit = "tier-3-complex"
# bug_fix = "tier-2-standard"

# ─── PR Review ──────────────────────────────────────────────────
# [pr_review]
# cloud_bot = true       # Set to false to skip @codex cloud review
#                        # and use local codex (csa review) instead.
#                        # Useful for repos without cloud bot access.

# ─── Aliases ────────────────────────────────────────────────────
# [aliases]
# fast = "codex/openai/gpt-5-codex-mini/low"
# heavy = "claude-code/anthropic/default/high"
"##,
        escaped_name = escaped_name,
        now = chrono::Utc::now().to_rfc3339(),
    );

    if let Some(parent) = config_path.parent() {
        std::fs::create_dir_all(parent)?;
    }
    std::fs::write(&config_path, &template)?;

    // Update .gitignore
    csa_config::init::update_gitignore(project_root)?;

    eprintln!("Generated config template at: {}", config_path.display());
    eprintln!("  All sections are commented out — uncomment to override global settings.");
    Ok(())
}

/// Get a raw config value by dotted key path.
///
/// Reads raw TOML files (not the merged/defaulted effective config).
/// Fallback order: project `.csa/config.toml` → global config → `--default`.
/// Use `--project` to skip global, `--global` to skip project.
pub(crate) fn handle_config_get(
    key: String,
    default: Option<String>,
    project_only: bool,
    global_only: bool,
    cd: Option<String>,
) -> Result<()> {
    // Try project config first (unless --global flag)
    if !global_only {
        let project_root = crate::pipeline::determine_project_root(cd.as_deref())?;
        let project_config_path = ProjectConfig::config_path(&project_root);
        match load_and_resolve(&project_config_path, &key) {
            Ok(Some(value)) => {
                println!("{}", format_toml_value(&value));
                return Ok(());
            }
            Ok(None) => {} // Key not found, try next source
            Err(e) => anyhow::bail!(
                "Failed to read project config {}: {e}",
                project_config_path.display()
            ),
        }
    }

    // Try global config (unless --project flag)
    if !project_only {
        match GlobalConfig::config_path() {
            Ok(global_path) => {
                match load_and_resolve(&global_path, &key) {
                    Ok(Some(value)) => {
                        println!("{}", format_toml_value(&value));
                        return Ok(());
                    }
                    Ok(None) => {} // Key not found
                    Err(e) => anyhow::bail!(
                        "Failed to read global config {}: {e}",
                        global_path.display()
                    ),
                }
            }
            Err(e) if global_only && default.is_none() => {
                anyhow::bail!("Cannot determine global config path: {e}");
            }
            Err(_) => {} // Non-critical when falling through to default
        }
    }

    // Fall back to --default or report key not found
    match default {
        Some(d) => {
            println!("{d}");
            Ok(())
        }
        None => anyhow::bail!("Key not found: {key}"),
    }
}

/// Load a TOML file and resolve a dotted key path.
///
/// Returns `Ok(None)` if the file doesn't exist or the key path is absent.
/// Returns `Err` if the file exists but cannot be read or parsed.
fn load_and_resolve(path: &std::path::Path, key: &str) -> Result<Option<toml::Value>> {
    let content = match std::fs::read_to_string(path) {
        Ok(c) => c,
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => return Ok(None),
        Err(e) => anyhow::bail!("{e}"),
    };
    let root: toml::Value = content
        .parse()
        .map_err(|e| anyhow::anyhow!("TOML parse error: {e}"))?;
    Ok(resolve_key(&root, key))
}

/// Navigate a TOML value by dotted key path (e.g., "tools.codex.enabled").
fn resolve_key(root: &toml::Value, key: &str) -> Option<toml::Value> {
    let mut current = root;
    for part in key.split('.') {
        current = current.as_table()?.get(part)?;
    }
    Some(current.clone())
}

/// Format a TOML value for stdout (inline for scalars, pretty for tables/arrays).
fn format_toml_value(value: &toml::Value) -> String {
    match value {
        toml::Value::String(s) => s.clone(),
        toml::Value::Integer(i) => i.to_string(),
        toml::Value::Float(f) => f.to_string(),
        toml::Value::Boolean(b) => b.to_string(),
        toml::Value::Table(_) | toml::Value::Array(_) => {
            toml::to_string_pretty(value).unwrap_or_else(|_| format!("{value:?}"))
        }
        toml::Value::Datetime(d) => d.to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn resolve_key_scalar() {
        let root: toml::Value = "[review]\ntool = \"auto\"\n".parse().unwrap();
        let val = resolve_key(&root, "review.tool").unwrap();
        assert_eq!(val.as_str(), Some("auto"));
    }

    #[test]
    fn resolve_key_nested() {
        let root: toml::Value = "[tools.codex]\nenabled = true\n".parse().unwrap();
        let val = resolve_key(&root, "tools.codex.enabled").unwrap();
        assert_eq!(val.as_bool(), Some(true));
    }

    #[test]
    fn resolve_key_missing() {
        let root: toml::Value = "[review]\ntool = \"auto\"\n".parse().unwrap();
        assert!(resolve_key(&root, "nonexistent.key").is_none());
    }

    #[test]
    fn resolve_key_partial_path() {
        let root: toml::Value = "[review]\ntool = \"auto\"\n".parse().unwrap();
        // "review" is a table, not a leaf — resolve_key returns the table
        let val = resolve_key(&root, "review").unwrap();
        assert!(val.is_table());
    }

    #[test]
    fn format_toml_value_string() {
        let v = toml::Value::String("hello".to_string());
        assert_eq!(format_toml_value(&v), "hello");
    }

    #[test]
    fn format_toml_value_integer() {
        let v = toml::Value::Integer(42);
        assert_eq!(format_toml_value(&v), "42");
    }

    #[test]
    fn format_toml_value_bool() {
        let v = toml::Value::Boolean(true);
        assert_eq!(format_toml_value(&v), "true");
    }

    #[test]
    fn load_and_resolve_missing_file() {
        let result = load_and_resolve(std::path::Path::new("/nonexistent/config.toml"), "key");
        assert!(result.unwrap().is_none());
    }

    #[test]
    fn load_and_resolve_invalid_toml() {
        let dir = tempfile::tempdir().unwrap();
        let path = dir.path().join("bad.toml");
        std::fs::write(&path, "{{invalid toml").unwrap();
        let result = load_and_resolve(&path, "key");
        assert!(result.is_err());
    }
}

pub(crate) fn handle_config_validate(cd: Option<String>) -> Result<()> {
    let project_root = crate::pipeline::determine_project_root(cd.as_deref())?;
    let config = ProjectConfig::load(&project_root)?
        .ok_or_else(|| anyhow::anyhow!("No configuration found. Run 'csa init' first."))?;

    // Check schema version compatibility
    config.check_schema_version()?;

    // Run full validation
    validate_config(&project_root)?;

    eprintln!("Configuration is valid (schema v{})", config.schema_version);
    Ok(())
}
